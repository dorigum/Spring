스프링 프레임워크 (Spring Framework)
- 엔터프라이즈 애플리케이션 구축을 위한 솔루션
- 자바 애플리케이션 개발을 위한 포괄적인 인프라 제공하는 자바 플래솦ㅁ
   - 스프링에서 인프라를 처리하므로 개발자는 애플리케이션 개발에만 집중
- 모듈화되어 있어서 필요한 부분만 사용 가능
- 완전한 기능을 갖추 MVC 프레임워크 제공
- 국내에서는 자바 개발자들에 표준 프레임워크 사용

스프링 프레임워크 선행 학습
- Java
- HTML / CSS / JavaScrip / jQuery
- JSP & Servlet

스프링의 장점
(1) 생산성 우수
-- 엔터프라이즈 애플리케이션 구축을 위한 솔루션이지만
-- 가볍고 모듈화되어 있어서 필요만 부분만 사용
-- POJO 클래스와 약간의 설정만으로도 개발이 가능하므로 개발 생산성을 높일 수 있음
-- 스프링 적용하면 개발 코드를 1/3 정도의 코드만으로도 개발 가능

EJB (Enterprise JavaBean)
- 규모가 커지고 복잡한 애플리케이션 제작을 위해 만들어진 기술
- extends, implemts를 많이 사용해서 클래스 의존도 높고, 복잡하고 제한이 많은 문제
- 이러한 문제 때문에
- 별도로 종속되지 않고 간단한 자바 객체를 사용하자라는 의도에서 POJO가 나옴

POJO (Plain Old Java Object)
- 특정 환경과 규약에 종속되지 않아 필요에 따라 재사용될 수 있는 방식으로 설계된 객체
- 즉, 복잡하게 다른 클래스를 상속받거나 인터페이스를 구현해야 하는 규칙이 없는 자바 클래스

POJP 대표적인 예
- Java Bean
- 생성자와 Getters / Setters 만 지닌 단순 자바 객체

대표적인 POJO 기반의 프레임워크
- 스프링 프레임워크

(2) 품질 보증
- 스프링 프레임워크는 이미 검증된 많은 아키텍처 및 디자인 패턴을 적용해서 만들어 졌기 때문에
- 코드에 아키텍처 구현하기 위한 코드나 디자인 패터을 사용하기 위한 코드를 개발자가 만들 필요 없음
- 개발에 일관성 제공해 주고 소프트웨어 품질 보증

(3) 유지 보수 용이
- 스프링 프레임워크를 사용해서 작성된 애플리케이션은 유지보수하는 소요되는 인력과 시간을 줄일 수 있음
- 그래서 여러 프레임워크 중에서 스프링 프레임워크가 업계 표준으로 자리 잡음

-------------------------------------------------------------------------------------
스프링 프레임워크 특징
(1) POJO 기반 프레임워크
(2) DI (Dependency Injection) 지원
(3) AOP (Aspect Oriented Programming) 지원
(4) 뛰어난 확장성
(5) Model2 방식의 MVC Framewordk 지원
(6) WAS에 종속되지 않는 개발 환경

(1) POJO 기반 프레임워크
- 자바 객체의 라이프사이클을 스프링 컨테이너가 직접 관리혹
- 스프링 컨테이너로부터 필요한 객체를 얻어 옴

(2) DI (Dependency Injection) 지원
- 의존성 주입
- 의존 관계에 있는 객체를 생성 조립해 주는 기능
- 각 계층이나 서비스들 사이 또는 객체들 사이의 의존성이 존재할 경우 스프링 프레임워크가 서로 연결시켜 줌
- 클래 간 약한 결합 가능
- A 클래스 B클래스의 객체를 사용할 때
-- 지금까지 B b = new B(); // 개발자가 필요할 때 언제든지 new 사용해서 의존관계가 있는 객체 생성/사용
-- 스프링에서는 new 연산자로 마음대로 객체 생성 못함
-- 스프링 컨테이너가 만들어서 넣어 주겠다는 의미

(3) AOP (Aspect Oriented Programming) 지원
- 관점 지향 프로그래밍
- 공통 기능을 분리해서 사용해서 사용
-- 트랜잭션 로깅, 보안 등 여러 모듈에서 공통적으로 지원하는 기능을 분리해서 사용 
- 반복적인 코드를 줄이고 개발자가 비즈니스 로직에만 집중할 수 있도록 지원

(4) 뛰어난 확장성
- 스프링 프레임워크의 소스는 모두 라이브러리로 분리되어 있어서
- 필요한 라이브러리만 가져다 사용하면 됨
- web.xml에 추가

(5) Model2 방식의 MVC Framewordk 지원
- Model / View / Controller
- JSP MVC 때보다 코드가 간결

핵심 기능
- DI (Dependency Injection) 주입 
-- 객체 간의 의존성을 개발자가 설정하는 것이 아니라
-- 스프링 컨테이너가 주입시켜 주는 기능
-- 장점 : 객체를 쉽게 확장하고 재사용할 수 있음
- IoC (Inversion of Control : 제어의 역전)
-- 객체에 대한 제어권 문제
-- 기존에는 개발자에게 제어원이 있었음 : new 연산자 사용해서 마음대로 객체 생성
-- 스프링 프레임워크에서는 객체의 제어권이 스프링에게 있고
-- 인스턴스의 라이프사이클(생성에서 소멸까지)을 개발자가 아닌 스프링 프레임워크에서 담당
-- 제어권이 역전되었다는 표현

----------------------------------------------------------------------------------------

개발환경 구성
- JDK
- Spring Toos 
-- STS (Spring Tool Suit) 사용 : 이클립스에 스프링 플러그인이 포함된 버전 -- 우리는 이 방식 사용
-- Eclipse에서 Spring Tools 플러그인 설치
- Tomcat
- Oracle Database 11g Release 2 : Express Edition

설치 및 환경 설정
- STS4 설치 : Spring Boot만 설치
- Spring Tools 3 Add-On 3.9.16 추가 설치
- Eclipse Java EE Developer Tools 설치

먼저 Workspace 생성
- springWorkspace

STS4 다운로드 받아서 압축해제하고 exe 파일 실행 사용

STS4 다운로드
- spring-tool-suite-4-4.10.0.RELEASE-e4.19.0-win32.win32.x86_64.self-extracting.jar
압축 해제 : 주이!
- 압축 해제 시 경로가 길다는 오류 발생
- C 또는 D로 이동하고
- 파일명을 sts.jar 로 줄임
- sts.jar 압축 해제
- contents.zip 압축 해제
- sts-4.10.0.RELEASE 폴더 이동
- SpringToolSuite4.exe 실행 (작업 표시줄에 고정)

메뉴 Help / Eclipas MarketPlace에서 다음 검색해서 설치
(1) STS로 검색 : Spring Tools 3 Add-On 3.9.16  - install
(2) Eclipse Java EE Developer Tools  검색 : 
-- Eclipse Enterprise Java and Web Developer Tools 3.21 - install
(3) Perspective 변경 : Open Perspective / Spring 선택해서 Open

환경 설정 : Window / Preference에서 다음 설정
(1) General / Workspace : 아래 오른쪽에 OTHER : UTF-8 로 변경
(2) HTML / CSS / JSP : UTF-8로 변경 (오른쪽 위에)
(3) Server 설정
   - Runtime Environment
   - Apache Tomcat v9.0
   - Create a new local server
   - 톰캣 폴더 선택
(4) Java Compiler 버전 변경 --> 1.8로 변경
     - Java / Compiler 오른쪽 위에 15 -> 1.8로 변경

----------------------------------------------------------------------------------------
스프링 프로젝트 유형
스프링 : 자바 기반 웹 프레임워크

스프링 웹 프로젝트
(1) Spring Legacy Project
-- 스프링 템플릿 프로젝트를 이용하는 프로젝트
(2) Spring Starter Project
-- Spring Boot을 이용하는 프로젝트

(1) Spring Legacy Project
- 스프링 템플릿 프로젝트를 이용하는 프로젝트
- 모델2 방식 (MVC)의 프로젝트 생성 시 사용
- Spring MVC Project
- 서버 및 여러 설정 필요
- 실제 개발 업무에서 많이 사용하는 프로젝트

(2) Spring Starter Project
- Spring Boot을 이용하는 프로젝트
- 최대한 간단하게 실행하고, 배포가 가능한 수준의 웹 어플리케이션을 제작하기 위한 목적
- 개발에 필요한 모든 환경을 설정을 갖추면서 최소한의 개발을 해야 하는 경우 사용
- 개발자가 복잡한 설정 없이 모든 개발 환경이 준비되기 때문에 초보 개발자도 쉽게 웹 프로젝트 생성 가능

Simple Spring Maven (Maven Project)
 - Spring 라이브러리의 기본 세트를 포함하는 Maven을 사용해서
- 간단한 Spring 프로젝트 생성

Maven (메이븐)
- Java 용 프로젝트 관리 도구
- XML 기반의 정적인 빌드 제공

Gradle(그레이들)
- 그루비(Groovy) 스크립트 기반의 동적인 빌드 기능 제공
- 안드로이드 앱 만들 때 필요한 공식 빌드 시스템
- 메이븐보다 빌드 작업이 간단
- 별도의 스크립트를 통해서 사용할 애플리케이션 버전, 라이브러리 등 설정 가능


------------------------------------------------------------------------------------------------

의존성 (Dependency)
- 객체 간 의존성
- 한 클래스에서 다른 클래스의 객체를 통해 그 클래스의 메소드를 실행할 때 '의존'한다고 표현
- xxxDAO dao;  xxxDTO dto;
- new 연산자를 통해 다른 클래스의 객체 생성해서 사용
--  BookDTO dto = new BookDTO();

A 클래스에서 B 클래스이 객체를 생성해서 사용하는 경우

(1) 지금까지 해왔던 개념
- A클래스에서 직접 생성
- 일체형으로 묶여 있음
- 강한 의존 관계
class A {
  privat B b;

  public A(){
     b = new B(); // B클래스의 객체 b 생성
   }
}

(2) 앞으로 사용할 개념 (DI)
- 외부에서 만든 객체를 받아서 사용
- (조립된 부품을 받아서 사용한다는 개념)

class A {
  privat B b;

  public void setB(B b){  // setter 메소드를 통해서 외부에서 넣어 줌 (injection)
     this.b = b;
  }
}

DI (Dependency Injection) 주입 
-- 객체 간의 의존성을 개발자가 설정하는 것이 아니라
-- 스프링 컨테이너가 주입시켜 주는 기능
-- 장점 : 객체를 쉽게 확장하고 재사용할 수 있음
- IoC (Inversion of Control : 제어의 역전)
- 외부에서 생성된 bean(객체)fmf IoC 컨테이너가 넣어 주는 방식 (주입 : injection)
- 일반적으로 부품(빈)을 조립(의존성 주입)해서 사용한다는 개념

DI(의존성 주입) 방법을 사용하는 이유
- 의존하는 객체의 클래스가 변경되거나 다른 클래스의 객체를 사용하게 될 경우
-- 의존 관계에 있는 다른 모든 클래스들의 소스 코드도 변경해햐 하는데
- 의존성 주입 방법을 사용하면, 클래스 결합 상태를 변경하거나 객체를 주입하는 부분만 수정하면 되므로
- 수정할 코드의 양을 줄일 수 있다는 장점이 있음
예) A1 클래스를 사용하다가 A2 클래스로 변경할 경우
- 설정 파일세서 클래스 이름만 변경해 주면 됨
<bean id="a" class="com.package.A1">
			       A2


스프링에서 의존성 주입 방법
(1) XML을 이용한 방법
- XML 설정 파일에 <bean> 설정
-- 생성자 기반 DI
-- Setter 기반 DI
(2) Annotation을 이용한 방법
- 자바 코드에서 '@어노테이션'으로 설정

------------------------------------------------------------------------------
프로젝트 생성
- 도메인 이름 형식 : com.company.app

Group id (도메인 이름) : com.di_project.ex
Artifact id (프로젝트 이름) : di_01

실습 예제
(1) DI를 사용하지 않은 예제
- Controller 클래스와 Service 클래스 사이에 의존성 존재
- Controller 클래스에서 new 연산자 사용해서 Service 클래스 객체 생성해서 사용
com.di.no_spring_no_di
- nameService
- nameController
- nameMain

(2) 생성자 기반 DI
- 의존성이 있는 객체를 new를 사용해서 직접 생성하지 않고
- 생성자를 통해 외부에서 전달 (주입 : inject)
- 아직 스프링의 DI는 아님
- com.di.no_spring_di_constructor

(3) Setter 기반 DI
- Setter 메소드를 사용해서 의존성 주입 수행
com.di.no_spring_di_setter

-----------------------------------------------------------------------------
Spring DI
스프링으 의존성 주입 : 스프링의 핵심 기능
- 스프링 프레임워크는 컨테이너 역할을 하기 때문에
- 스프링 컨테이너(IoC 컨테이너)라고도 함
- 스프링은 필요한 빈을 생성해서 컨테이너에 넣어 관리
- 필요한 곳에 주입해 줌
- 빈을 생성하기 위한 설정과 의존 객체를 주입시키는 설정 필요

2가지 Spirn DI
(1) XML을 이용한 DI : 별도의 설정파일(xml)을 사용해서 빈 생성, 객체 주입 설정
    - 생성자 기반 DI
    - Setter 기반 DI
(2) Annotation을 이용한 DI

(1) XML을 이용한 DI
- XML 파일에
-- 빈(Bean: 부품)을 정의(생성)하고
      - <bean id="빈이름" class="패키지명.클래스명">
-- 의존성 설정 (부품 조립 : DI )
     - <ref bean="의존하는 빈">
- XML을 이용해서 의존성을 주입하기 위해서는
-- 생성자 기반일 때는 생성자가 반드시 있어야 하고
-- Setter 기반일 때는 Setter 메소드가 반드시 있어야 함


스프링은 Pre-loading 방식 사용
- ApplicationContex를 이용해서 컨테이너를 구동하면 
- 컨테이너가 구동되는 시점에 스프링 설정 파일에 등록된 빈을 생성하고 컨테이너에 로드

-----------------------------------------------------------------------------------------------------
스프링 DI 실습
(1) XML을 이용한 DI : 생성자 기반
 - 클래스에 생성자가 있어야 하고
 - 스프링 설정 파일(xml)에서 빈을 정의할 때
   <constructor-arg ref="의존하는 빈">
com.di_spring_di_xml_constructor

설정 파일 생성 : xml 
src/main/resources 폴더에 Srping Bean Configuration File 선택하고
application-context.xml

NameMain 클래스에서 하는 역할
- 컨테이너 객체를 생성하고  ;
AbstractApplicationContext context = 
	new GenericXmlApplicationContext("application-context.xml");
라이브러기 없어서 오류 -> pom.xml 파일에 라이브러리 추가
- 컨테이너에 컴포넌트(빈) 가져옴


pom.xml 파일에서 Dependencies Add 안될 때
Window / Preference
- 왼쪽에서 Maven : 오른쪽에서 [Download repository index updates on startup 체크
- Apply and Close 창 닫고
Window / Show View / Other
- Maven : Maven Repositories 서택하고 open
오른쪽 아래에 창이 열리면
Global Repositories / central에 우클릭하고 Rebuild Index
- 시간이 오래 걸림
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>5.2.13.RELEASE</version>
  	</dependency>
  	<dependency>

-----------------------------------------------------------------------------------------------
연습문제1
패키지 : com.di.spring_di_xml_constructor_ex1
클래스 생성
- Speaker 클래스
   -- volumeUp() : 볼륨을 키웁니다
   -- volumeDown() : 볼륨을 낮춥니다
- TV 클래스
   -- Speaker speaker;
   -- volumeUp() / volumeDown()
   -- TV 클래스에서 Speaker 클래스의 volumeUp()/volumeDwon()를 호출해서 볼륨 조졸
- TVMain 클래서
- XML 기반으로 생성자를 통해 DI 구현
   -- appplication-context2.xml


-----------------------------------------------------------------------------------------------
(2) XML을 이용한 DI : Setter 기반
 - 클래스에 반드시 Setter 메소드가 있어야 한다
 - 생성자 사용 안함 (기본 생성자 외에 다른 생성자 없음)
 - 스프링 설정 파일 (xml)에서 <property> 태그 이용해서 의존 객체 주입
 - <property name="nameService" ref="nameService">
    -- name : setter 메소드 이름 (setNameService())
    -- ref : 참조 객체 이름 (참조하는 빈 이름)

패키지 : com.di.spring_di_xml_setter

----------------------------------------------------------------------------------------
연습문제2
패키지 : com.di.spring_di_xml_setter_ex1
클래스 생성
- Speaker 클래스
   -- volumeUp() : 볼륨을 키웁니다
   -- volumeDown() : 볼륨을 낮춥니다
- TV 클래스
   -- Speaker speaker;
   -- volumeUp() / volumeDown()
   -- TV 클래스에서 Speaker 클래스의 volumeUp()/volumeDwon()를 호출해서 볼륨 조졸
- TVMain 클래서
- XML 기반으로 Setter 메소드를 통해 DI 구현
   -- appplication-context4.xml

----------------------------------------------------------------------------------------

설정 파일에서 빈 생성하면 값 초기화 (값 설정)
- 생성자 기반
- Setter 기반
com.di.spring_xml_value_constructor
com.di.spring_xml_value_setter

연습문제3
com.di.spring_xml_value_setter
application-context7.xml
Book 클래스
- 설정 파일에서 빈 생성하면서 값 초기화 
- Setter 기반


설정 파일에서 빈 생성하면 값 초기화 (값 설정) - 의존성 주입
com.di.spring_di_xml_value_contructor

설정 파일에서 빈 생성하면 값 초기화 (값 설정) - 의존성 주입 
- Setter 기반
com.di.spring_di_xml_value_setter
- application-context8.xml
- BMI / Member / MemberMain

------------------------------------------------------------------------------------------
스프링에서 Singleton
- 스프링 컨테이너는 빈을 생성할 때 싱글톤 패턴을 적용하지 않아도
- 항상 클래스당 1개의 인스턴스만 생성 (디폴트)

singleton 속성 변경 가능
- <bean> 태그의 scope 속성을 이용해서
- 빈이 싱글톤으로 생성되게 할지
- 아니면 요청할 때마다 생성되게 할지 설정 가능
- scope 속성 값 : singleton(디폴트), prototype, thread, request, session, application

==========================================================
Annotation을 이용한 DI
- xml 설정 파일에서 <bean> 태그를 이용해서 설저하였던 빈 설정을
- Annotation(메타데이터)를 이용해서 자바 코드에서 설정
예 : xml 설정 파일에서 빈을 설정하지 않ㄴ고
- 스프링이 자바 소스 코드를 읽어서
- 클래스에 @Component 어노테이션이 붙은 클래슬 객체화 (bean 설정)
- A1 클래스의 객체를 A2클래스의 객체로 변경하려면
-- A1 클래스에서 @Component을 제거하고 
-- A2 클래스에 @Component을 붙이면 됨
--@Autowired 어노테이션을 사용하여 bean 자동 삽입

xml 설정 파일에 context 네임스페이스 추가
- 빈 설정을 위한 어노테이션을 사용하기 위해서는
- 설정 파일에 context 네임스페이스가 추가되어 있어야 함
- <context:component-scan> 태그 이용해서 빈으로 등록될 클래스 패키지 지정
- 의미 : 자바 소스 코드에서 @Component로 등록된 클래스를 찾아서(scan) 클래스를 객체화(빈 설정)

Annotation 종류
- 빈 생성과 관련 Annotation
    @Component
      - @Controller
      - @Service
      - @Repository
    @Configuration
      - @Bean
- DI 관련 Annotation
--@Autowired / @Inject
--@Qualifer
--@Resource

DI 관련 Annotation
- xml 설정 파일에 있는 <bean>에 대해 DI 하거나
- 자바 코드에서 생성된 bean에 대해 DI할 수 있음
- @Autowired : 타입을 기준으로 의존성 주입
-- 스프링 빈에 의존하는 다른 빈을 자동으로 주입할 때 사용
-- 스프링에서 지원
-@Inject : @Autowired와 동일 (자바에서 지원)
-@Qualifer : 특정 빈의 이름 지정
-- 동일한 interface를 구현한 클래스가 여러 개 있는 경우
-- 사용하고자 하는 특정 빈의 이름을 지정할 때 사용
-@Resource : @Autowired와 @Qualifer를 같이 사용하는 것과 동일 (자바에서 지원)


프로젝트 새로 생성
New / Maven 프로젝트 생성
- Create a simple project 체크
- Group Id (도메인 이름) : com.di_project.ex
- Aritifact Id (프로젝트 이름) : di_02
- pom.xml <dependencies> 추가 : di_01프로젝트에서 복사
 <dependencies>
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>5.2.13.RELEASE</version>
  	</dependency>
  </dependencies>


패키지 생성 : com.spring_di_annotation
필요한 클래스
- INameService 인터페이스 
- NameService 클래스
- NameController 클래스
- NameMain 클래스

설정 파일 : application-context.xml
- Annotation을 사용하기 위해서는 context 네임스페이스 추가
-- application-context.xml 생성한 후 아래쪽에 Namespaces 탭 선택
-- context 체크
- 빈 생성

(1) @Autowired : 스프링 빈에 의존하는 다른 빈을 자동으로 주입할 때 사용
(2) @Qualifer : 동일한 interface를 구현한 클래스가 여러 개 있는 경우
	       -- 사용하고자 하는 특정 빈의 이름을 지정할 때 사용
(3) @Resource : @Autowired와 @Qualifer를 같이 사용하는 것과 동일

@Autowired의 위치
- 클래스 선언부 : 기본 생성자를 호출하면서 injection
- Setter 메소드 위에 : Setter 메소드 호출하면서 injection
 
-------------------------------------------------------------
빈 생성과 관련 Annotation
    @Component
      - @Controller
      - @Service
      - @Repository
    @Configuration
      - @Bean

빈 생성 어노테이션
- 빈 생성(설정)을 위해 클래스 위에 추가되는 어노테이션
- 클래스 이름 위에 붙이면 해당 클래스 파일에 대한 bean 자동 생성 
-(xml 파일에서 bean 생성하지 않음)
- 빈의 이름은 클래스 이름에서 첫 문자 소문자
예: NameService 클래스의 빈 이름은 nameService

어노테이션을 이용하기 위해 xml 설정 파일에서 필요한 작업
- xml 설정 파일에 context 네임스페이스 추가 필요
<context:component-scan base-package="패키지명" />
-@Component 어노테이션이 적용된 클래스를 빈으로 등록

@Component 어노테이션
- 클래스를 빈으로 등록 (부품 등록)
- 빈 id 지정 가능
- @Component("빈이름") == <bean id="빈 이름">에 해당

패키지 : com.spring_di_annotation_component
사용 클래스
- INameService 인터페이스: 변경 없이 그대로 사용
- NameService 클래스 : 빈 생성
-- @Component 어노테이션 추가
- NameController 클래스 : 빈 생성
-- @Component 어노테이션 추가
   -- 생성자 삭제
   -- NameService 객체 사용
-NameMain 클래스 : xml 파일명만 변경
-- NameController 클래스 사용

@Component 어노테이션의 의미론적 어노테이션
@Component : 일반적인 컴포넌트
특화된 @Component 어노테이션
- 클래스의 역할에 따라 의미론적으로 구분
-- @Controller 컴포넌트 : 컨트롤러 클래스에 사용
-- @Service 컴포넌트 : 서비스 클래스에 사용
-- @Repository 컴포넌트 : DAO 클래스 또는 Repository 클래스에 사용

패키지 : com.spring_di_annotation_component2


--------------------------------------------------------------------------
설정 담당 자바 클래스에서 사용하는 어노테이션
@Configuration
- 빈 설정 클래스임을 나타내는 어노테이션

@Bean 
- 빈을 생성해서 반환해주는 어노테이션
- 빈을 생성하는 메소드 앞에 기술
- @Bean이 붙은 메소드는 반드시 Bean 반환

@Bean 어노테이션을 사용하는 경우
- 일반적으로 @Controller, @Service, @Repository 어노테이션을 붙이지 않는 클래스의 빈 생성에 사용

패키지명 : com.spring_di_annotation.configuration_bean
사용 클래스
- BMI
- Member
- MemberMain
- ApplicationConfig.java


=========================================================
Spring MVC 구조

- Spring MVC Project 생성
- 설정
- 구조 확인
- 데이터 전송
- 폼을 통한 데이터 전송

New / Spring MVC Project
프로젝트 이름 : spring_mvc_01
패키지 이름 : com.spring_mvc.project

(1) pom.xml 버전 변경
기본 환경 확인
- Spring Framework 3.1.1
- Java version 1.6
- Maven compiler
-- source 1.6
-- target 1.6

변경할 버전
-Spring Framework 4.3.4
- Java version 1.8
- Maven compiler
-- source 1.8
-- target 1.8

(2) 프로젝트 설정 변경 (프로젝트 이름 우클릭)
- Java Compiler : 1.8
- Java Build Path : JRE 수정
- Project Facets : Java 버전 변경 (1.8)

(3) Maven / Update Project


----------------------------------------------------------
프로젝트 이름 : spring_mvc_01
패키지 이름 : com.spring_mvc.project
http://localhost:8080/project/


프로젝트 처음 생성 시
- 기본 컨트롤러 포함되어 있음 : HomeController
-- src / main
-- C:\springWorkspace\spring_mvc_01\src\main\java\com\spring_mvc\project
- 기본 view 페이지 : home.jsp
-- 아래 : src / main/ webapp/WEB_INF/views/ 여기에 home.jsp 들어 있음

HomeController
- @RequestMapping(value = "/", method = RequestMethod.GET)
- 요청 url 맵핑 : "/" : /project를 의미 : 요청을 받고
--처리 작업
- 결과를 View 페이지에 전송
-- return "home";  // view 페이지 이름 : home.jsp

/WEB-INF/views/ + view 페이지 이름 + .jsp

설정 파일 확인
1. web.xml  : /  :요청 url 맵핑 : "/" : /project를 의미 : 요청을 받고
(1) 요청 url 
- <servlet-mapping>
	<servlet-name>appServlet</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>

(2) DispatcherServlet : 컨트롤러를 찾아서 작업 처리
(3) 스프링 컨테이너 설정 파일 위치 지정
/WEB-INF/spring/appServlet/servlet-context.xml

2.  servlet-context.xml 파일 확인
- 응답 페이지 설정되어 있음
- ViewResolver가  jsp 위치 찾고, 해당 jsp 파일 찾도록 설정
-(1) "/WEB-INF/views/ : view 페이지의 위치
-(2) name="suffix" value=".jsp" : 뷰페이지 이름 확장자 (.jsp 파일)
-- view 페이지 위치 +   여기에 뷰 페이지 이름     + .jsp : 뷰 페이지로 설정

컨트롤러에서 뷰 페이지 이름 반환 : home

스프링의 디렉터리 구조
- src/main/java : 자바코드 위치(Controller, Service, model)
- src/main/resources : 자바 코드에서 참조하는 리소스 파일들 (DB 설정파일)

- src/main/webapp : 웹 서비스 루트 디렉터리 (외부에서 접근 가능)
- src/main/webapp/resources : js, css, image 등 리소스 파일

- src/main/webapp/WEB-INF/spring : 스프링 환경 설정 파일 
	-- servlet-context.xml : 서블릿과 관련된 리소스에 대한 설정
	-- root-contxt.xml : 서블릿과 관련 없는 모든 리소스에 대한 설정

- src/main/webapp/WEB-INF/views : html, jsp 페이지 (컨트롤러를 경유해서 접근 가능) (외부에서는 직접 접근 불가(보안상)

server.xml에서 context path 확인 : 패캐지 이름에서 맨 마지막 . 다음에 오는 이름이 컨텍스트 패스가 됨
<Context docBase="spring_mvc_01" path="/project"

패키지 이름 : com.spring_mvc.project
http://localhost:8080/mvc/
http://localhost:8080/mvc/project

http://localhost:8080/mvc/WEB-INF/classes/com/spring_mvc_01/project/HomeController.java
http://localhost:8080/project/WEB-INF/classes/com/spring_mvc/project/HomeController.java


------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------
스프링 컨트롤러
- 스프링 컨트롤러는 빈으로 등록되어야 하며
- 비즈니스 로직이 실행되기 전에 비즈니스 객체를 의존성 주입(DI) 해야 함
- @Controller 어노테이션 사용
- @RequestMapping 어노테이션을 사용해서 url 맵핑 : 사용자의 요청 받음


- 컨트롤러 클래스 새로 작성
- 클래스 생성하고  @Controller 어노테이션 붙임
- @RequestMapping 어노테이션을 사용해서 요청 경로 지정
- 요청 처리 메소드 구현
- 뷰 페이지 이름 반환 : return "jsp 페이지 이름"


---------------------------------------------------------------
연습문제
- 새 컨트롤러 생성 : SecondController
- url 맵핑 : /secondView
- jsp 페이지 : views/second 폴더 만들어서 그 안에 secondView.jsp 생성
- SecondController에게 요청해서 secondView.jsp 출력

-------------------------------------------------------------------------------
컨트롤러에서 View 페이지로 데이터 전달 방법
(1) Model 인터페이스 객체 사용
(2) ModelAndView 클래스 객체 사용

(1) Model 인터페이스
- Model에 Attributes 추가하는데 사용
- ("key", value) 형태로 값을 임시 저장
- Controller에서 Model에 데이터 저장하고
- View 이름 return 하면
- View 페이지로 Model 전달되고
- View 페이지에서 key를 사용해서 Model에 저장된 Data 사용 : ${key }

나이 : 30
주소 : 서울시 강남구
전화 : 010-1234-1234


(2) ModelAndView 클래스 객체 사용
- 데이터와 뷰 둘 다 설정
-- 데이터 설정 : addObject(key, value)
-- 뷰 이름 설정 : setViewName("jsp파일 이름")
- 반환값으로 ModelAndView 객체 반환
- ModelAndView mv = new ModelAndView();
- mv.addObject("name", "홍길동")
- mv.setViewName("showInfo");   // showInfo.jsp
- return mv;


연습문제
- 컨트롤러 : BookController
- Views 폴더 안에 book 폴더 생성 : bookInfoView.jsp

- 데이터 
-- 제목 : 스프링 프레임워크
-- 가격 : 20000
-- 저자 : 홍길동

- 메소드 
- showBookInfo1() : Model 사용
- showBookInfo2() : ModelAndView 사용

- 요청 url 
- bookInfoView1
- bookInfoView2

--------------------------------------------------------------------
@RequestMapping 다중 맵핑
- 한 개의 메소드를 사용해서 여러 요청 경로로 접근 처리 가능
- @RequestMapping(value={"요청경로1", "요청경로2"})


--------------------------------------------------------------------
Form 데이터 처리
- 폼에 입력된 값을 컨트롤러로 전송
- 스프링에서 HTTP 요청 파라미터 가져오는 방법 3가지
(1) getParameter() 메소드 사용
(2) @RequestParam 어노테이션 사용
(3) Command 객체 이용
- Student 클래스 생성하고 요청을 수행하는 메소드에서 Student 객체 사용 (커맨드 객체)
- Command 객체는 자동으로 View Model에 등록
- View 페이지에서 ${객체.필드명}

index.jsp 만들고 
실행하면 바로 index.jsp 실행되게 설정

요청 : / 이면
view 이름 : index


@ModelAttribute 어노테이션
- Comman 객체 이름 변경 가능
- Student student 인 경우 : ${stuedent.no}

- @ModelAttribute("studentInfo") Student student
- ${studentInfo.no}


------------------------------------------------------------------------------
연습문제

새 프로젝트 : spring_mvc_02
패키지 : com.spring_mvc.product
(http://localhost:8080/product/)

상품 정보를 등록하는 프로그램 작성
- 상품 정보 등록 폼에서 입력한 데이터를 컨트롤러에게 전송하고
- 컨틀로러에서 받아온 데이터를 View 페이지로 출력
- 3가지 방법 사용 (getParameter() / @RequestParam /Command 객체)

- 컨트롤러 : ProductController
- 폼 : productForm.jsp
- 결과 출력 : productResult1.jsp, productResut2.jsp

- jsp 위치 : product 폴더 만들고 그 안에 위치
- insertProduct1() / insertProduct2() / insertProduct3()


------------------------------------------------------------------------------------------

MyBatis(마이바티스)
- ORM(Object Relation Mapping: 객체 관계 맵핑) 프레임워크
- 자바에서 JDBC를 이용해서 데이터베이스 연동할 때
- Java 언어와 sql 언어가 한 파일에 존재하면서 재사용성이 좋지 않음
- MyBatis는 JDBC의 이런 단점을 개선해서 sql 명령어를 별도의 xml 파일로 분리해서
- sql 명령어와 자바 객체를 맵핑해준 기능을 제공
- sql 명령어 재사용 가능

MyBatis 특징 : SQL 명령어를 자바 코드에서 분리해서 XML 파일에서 관리

JDBC를 사용할 경우
- Controller  -> IService/Service  -> IDAO(선택) / DAO (sql 문장)  -> DB

MyBatis 사용할 경우
- Controller  -> IService/Service  -> IDAO(필수) / mapper.xml(sql 문장)  (DAO 대신 mapper.xml 사용)



스프링 MyBatis 사용하기 위한 설정 
(1) 프로젝트 생성
(2) pom.xml에서 의존성 설정
    - 프로젝트 
	- Java Compiler : 1.8
	- Java Build Path : JRE 수정
	- Project Facets : Java 버전 변경 (1.8)
    - 데이터베이스 (Spring JDBC 의존성 / Connection Pool 의존성 / Oracle JDBC Driver 의존성)
    - MyBatis 
(3) web.xml 인코딩 필터 추가
(4) 프로퍼티 파일 작성 : jdbc.properties
(5) 스프링 설정 파일 생성 : application-config.xml
     - DataSource / Mapper 지정
(6) web.xml : 스프링 설정 파일 지정
(7) 클래스 구성 (CRUD)
    Controller
    IService / Service
    VO
   IDAO / mapper.xml
  뷰 페이지 (jsp) : select / insert / update / delete / index

		

데이터베이스 작업
- 관리자 : 사용자 생성 : SRPING
- 새접속 : SPRING실습
- 사용자 : SPRING
- 비밀번호 : 1234
- 테이블 생성 : product


------------------------------------------------------------------------------------------------------------
1. 프로젝트 생성

New / Spring MVC Project
프로젝트 이름 : spring_mvc_mybatis
패키지 이름 : com.spring_mvc.mybatis

(1) pom.xml 버전 변경
기본 환경 확인
- Spring Framework 3.1.1
- Java version 1.6
- Maven compiler
-- source 1.6
-- target 1.6

변경할 버전
-Spring Framework 4.3.4
- Java version 1.8
- Maven compiler
-- source 1.8
-- target 1.8

(2) 프로젝트 설정 변경 (프로젝트 이름 우클릭)
- Java Compiler : 1.8
- Java Build Path : JRE 수정
- Project Facets : Java 버전 변경 (1.8) / 톰캣 체크

(3) Maven / Update Project (데이터베이스와 마이바티스 설정 끝난 후에)

------------------------------------------------------------------------------------------------------------------
 데이터베이스 (Spring JDBC 의존성 / Connection Pool 의존성 / Oracle JDBC Driver 의존성)
ojdbc-6.jar

C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib 에 들어 있는 ojdbc6.jar 파일을 아래 폴더에 복사하고
C:\Users\student\.m2\repository\com\oracle\ojdbc\6 폴더에 저장 (폴더 없으면 새로 생성)
파일명을 ojdbc-6.jar 파일로 변경

---------------------------------------------------------------------------------------------------------------------
MyBatis 의존성 설정

<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.5.6</version>
		</dependency>
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>2.0.6</version>
		</dependency>
-------------------------------------------------------------------------------------------------------------------------

(3) web.xml 인코딩 필터 추가  (한글 깨짐 방지)

------------------------------------------------------------------------------------------------------------------------

(4) 프로퍼티 파일 작성 : jdbc.properties
위치 : src/main/resources에 database 폴더 만들고 jdbc.properties 파일 생성

데이터베이스 연결 정보 설정
- 프로퍼티 파일에 작성 해 놓음
- 이 파일 안 만들고 설정 파일 안에 직접 넣어도 됨
- 프로퍼티 파일을 만들어서 사용하는 이유 : 보안 때문
-- DB 연결 정보는 내용이 변경될 수 있으므로 외부 .properties 파일로 작성해서 별도로 관리
-- git 저장소에 DB 접속 정보가 노출되지 않도록 하기 위함

------------------------------------------------------------------------------------------------------------------
(5) 스프링 설정 파일 생성 : application-config.xml
     - DataSource / Mapper 지정

위치 : src/main/resources에 spring 폴더 만들고 application-config.xml 파일 생성

----------------------------------------------------------------------------------------------
(6) web.xml : 스프링 설정 파일 지정


	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:/spring/application-config.xml</param-value>
	</context-param>


================================================================

(7) 클래스 구성 (CRUD)
    Controller
    IService / Service
    VO
   IDAO / mapper.xml
  뷰 페이지 (jsp) : select / insert / update / delete / index

------------------------------------------------------------------------------------------------------------

패키지 생성
controller : ProductController 클래스    @Controller / @Autowired
dao : IProductDAO (인터페이스)
       ProductMapper.xml
model : ProductVO 클래스
service : IProductService 인터페이스     @Service
           ProductService 클래스
          

--------------------------------------------------------------------------------
ProductMapper.xml
https://mybatis.org/mybatis-3/getting-started.html 에서 복사

<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">


----------------------------------------------------------------------------------
사용자 요청 (전체 상품 조회)   ->  Controller    ->  Service      ->    IDAO/Mapper.xml
		 	<-	      <-		<-					


상품 등록  -> 상품 등록 폼 이동 (입력) ->  저장

-----------------------------------------------------------------------------------------------------
연습문제
- 새프로젝트 생성 
- 도서 관리 프로그램 작성
- 테이블 : 새로 작성 또는 기존 테이블 사용

프로젝트 : spring_mvc_mybatis_book
패키지명 : com.spring_mybatis.book
도서 관리 프로그램 작성
- 전체 도서 정보 조회
- 도서 상세 정보 조회
- 도서 정보 등록
- 도서 정보 수정
- 도서 정보 삭제


=================================================================
Ajax (Asynchronous JavaScript and XML)
- 클라이언트에서 비동기 방식으로  자바스크립트를 이용해서
- 화면 전환 없이 서버 측에 데이터를 요청할 때 사용
- HTML, XML, JOSN, 텍스 등의 다양한 데이터 처리 가능
- 웹 서버 환경에서 실행

형식 : jQuery 형식 (jQuery 파일이 있어야 함)
$.ajax({
  url : "전송되는 페이지 ( ~로 전송)",
  type: "데이터 전송 방식 (get/post)",
  data: "전송할 데이터",
  dataType: "요청하는 데이터 타입(html, xml, json),
  success: function(data, textStatus){  //결과를 받을 매개변수 사용
     전송 및 요청 성공 시 실행 부분
  }, 
  error: function(data, , textStatus){
    오류 발생 시 실행 부분
  },
  complete:function(data, , textStatus){
    완료 시 실행 부분
  }
});

$.ajax() 메소드
- 사용자가 지정한 URL 경로에 있는 파일의 데이터를 전송하고
- 입력한 URL 경로의 파잉로부터 요청한 데이터를 불러오는데 사용
- 불러올 수 있는 외부 데이터는 텍스트, HTML, XML, JSON 유형 등

serialize() : 폼에 입력한 값을 쿼리 스트링 방식의 데이터로 변환여 액션 페이지에 전송
- 예 : 'id=abcd&pawd=1234$name=kim,...'

과제1 : html/JavaScript : 입력한 값 alert()추력
과제2: Ajax() 사용해서 서버로 보내고
 (가정: DB에서 다 처리했다고 하고 가정하고) 
보낸 값을 다시 클라이언트로 보내서 alert() 출력

--------------------------------------------
서블릿 : AjaxTest1 (/ajaxTest1)

클라이언트로 부터 데이터 받아서
Console에 출력하고
클라이언트에게 "안녕하세요. 서버입니다." 결과 데이터 전송

-----------------------------------------------------------------------------------------------------
CDATA : Unpared Character Data
- 파싱되지 않는 문자 데이터 
- sql 쿼리 작성할 떄 <, >, &, || 등을 사용해야 하는 경우 
- XML에서 태그로 인식해서 오류가 발생
- XML에게 XML 파싱 대상이 아니고 단순 문자열로 처리하라는 의미

<![CDATA[
select * from product where prdPrice > 10000;
]]>

-------------------------------------------------------------------------------------------------------
스프링 REST API

REST 
- 브라우저에서 페이지 요청 시
- PC에서는 페이지 전체를 다시 전송해서 표시해도 문제 없지만
- 스마트폰 등의 모바일 기기에서는 기존 화면은 그대로 유지하면서 필요한 내용만 추가해서 화면엣 표시
- 모바일 기기가 유선 기기보다 네트워크 전송량이 떨어지므로 
- 현재 화면은 그대로 유지하면서 필요한 데이터만 전송 받아서 빠르게 표시하기 위해서
- 대표적인 경우 : Ajax 이용
- 따라서 데이터만 전송하는 기능 표준화 필요성에 대두되면 REST 방식이 대안으로 사용됨

REST (Represnetation State Transfer)
- URI가 고유한 리소스를 처리하는 공통 방식
- 세션 정보나 쿠키 정보를 별도 저장하고 관리하지 않고 API 서버는 들어오는 요청만 단순 처리
- RESP API 설계 기준
 - URI 정보의 자원 표현
 - 자원에 대한 행위 HTTP(GET, POST, PUT, DELETE)로 표현

- REST API 중심 규칙
- URI는 정보의 자원을 표현해야 한다
- 자원 표현 
GET /members/1
DELET /members/2
POST /members/3
- 슬래시 구분자는 계층 관계를 나타내는 대 사용
- 마지막에는 슬래시 (/) 포함하지 않음
- URI 소문자로 사용
- 파일 확장자는 포함하지 않음

REST 방식으로 제공되는 API를 REST API (또는 RESTful API)라고 함
- 트위터와 같은 Open API 에서 많이 사용
- 정송 방식을 나타내는 메소드 속성의 값에 따라 리소스에 대한 추가 작업 요청 

스프링에서의 REST 방식의 데이터 처리
- 스프링 3버전 : @ResponseBody 어노테이션 지원
- 스프링 4버전 : @RestController 어노테이션

@RestController 이용해 REST 기능 구현
- 컨트롤러에서 브라우저로 기본형 데이터, VO 객체의 속성 값, Map에 저장된 데이터 전송
 - 서버 --> 클라이언트 데이터 전송

@Controller VS @RestController
- @Controller : 결과를 jsp(view)로 표시
- @RestController : 별도의 view를 제공하지 않은 채 데이터 전달


=================================================================
@RestController 사용해서 클라이언트로 문자열 전송

프로젝트 생성 : Spring MVC Project
프로젝트명 : spring_mvc_rest
패키지명 : com.spring_mvc.rest

1.8
4.3.4
1.8
1.8

(1) Java Compiler : 1.8
(2) Build Path : JRE edit 
(3) Project Facets : 1.8, 3.0, Runtime Server

--------------------------------------------------------------------------------------------------
- servlet-context.xml 설정 파일에서 
- 컨트롤러 없이 index 페이지 설정하는 방법
<mvc:view-controller path="/" view-name="index" />

-------------------------------------------------------------------------------------------------

@RestController를 이용해서 VO 객체 전달
- VO 객체의 속성 정보를 JSON 형식으로 전달
- pom.xml JSON 의존성 추가
<!-- JSON  --> 
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.5.4</version>
</dependency>

@RestController를 이용해서 컬렉션 객체 전달
- List를 JSON으로 만들어서 전송

@RestController를 이용해서 Map 전달
- Map에 저장된 데이터 전송

@PathVariable을 사용하면 브라우저에서 요청 URL로 전달된 매개변수 값을 가져올 수 있음

----------------------------------------------------------------------
@RequestBody와 @ResponseBody 사용하기
- 실제로 REST는 Ajax 기능과 연동해서 자주 사용
- 브라우저에서 JSON 데이터를 컨틀로러 전송될 때 컨트롤러에서 JSON 객체로 변환하는 기능 구현

@RequestBody : 브라우저에서 전달되는 JSON 데이터를 객체로 자동 변환 (클라이언트 -> 서버)
@ResponseBody : 브라우저에게 JSP가 아닌 텍스트나 JSON으로 결과 전송 (서버 -> 클라이언트)
   - @Controller 클래스에서 사용

리소스 파일 (image, css, js)  경로 설정
- servlet-context.xml
<mvc:resources location="/resources/" mapping="/**" />
<mvc:resources location="/resources/js/" mapping="js/**" />

- src/main/webapp/resources 폴더

------------------------------------------------------------------------------------------------------
views에 JSONTest.jsp






















