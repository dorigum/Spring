스프링 프레임워크 (Spring Framework)
- 엔터프라이즈 애플리케이션 구축을 위한 솔루션
- 자바 애플리케이션 개발을 위한 포괄적인 인프라 제공하는 자바 플래솦ㅁ
   - 스프링에서 인프라를 처리하므로 개발자는 애플리케이션 개발에만 집중
- 모듈화되어 있어서 필요한 부분만 사용 가능
- 완전한 기능을 갖추 MVC 프레임워크 제공
- 국내에서는 자바 개발자들에 표준 프레임워크 사용

스프링 프레임워크 선행 학습
- Java
- HTML / CSS / JavaScrip / jQuery
- JSP & Servlet

스프링의 장점
(1) 생산성 우수
-- 엔터프라이즈 애플리케이션 구축을 위한 솔루션이지만
-- 가볍고 모듈화되어 있어서 필요만 부분만 사용
-- POJO 클래스와 약간의 설정만으로도 개발이 가능하므로 개발 생산성을 높일 수 있음
-- 스프링 적용하면 개발 코드를 1/3 정도의 코드만으로도 개발 가능

EJB (Enterprise JavaBean)
- 규모가 커지고 복잡한 애플리케이션 제작을 위해 만들어진 기술
- extends, implemts를 많이 사용해서 클래스 의존도 높고, 복잡하고 제한이 많은 문제
- 이러한 문제 때문에
- 별도로 종속되지 않고 간단한 자바 객체를 사용하자라는 의도에서 POJO가 나옴

POJO (Plain Old Java Object)
- 특정 환경과 규약에 종속되지 않아 필요에 따라 재사용될 수 있는 방식으로 설계된 객체
- 즉, 복잡하게 다른 클래스를 상속받거나 인터페이스를 구현해야 하는 규칙이 없는 자바 클래스

POJP 대표적인 예
- Java Bean
- 생성자와 Getters / Setters 만 지닌 단순 자바 객체

대표적인 POJO 기반의 프레임워크
- 스프링 프레임워크

(2) 품질 보증
- 스프링 프레임워크는 이미 검증된 많은 아키텍처 및 디자인 패턴을 적용해서 만들어 졌기 때문에
- 코드에 아키텍처 구현하기 위한 코드나 디자인 패터을 사용하기 위한 코드를 개발자가 만들 필요 없음
- 개발에 일관성 제공해 주고 소프트웨어 품질 보증

(3) 유지 보수 용이
- 스프링 프레임워크를 사용해서 작성된 애플리케이션은 유지보수하는 소요되는 인력과 시간을 줄일 수 있음
- 그래서 여러 프레임워크 중에서 스프링 프레임워크가 업계 표준으로 자리 잡음

-------------------------------------------------------------------------------------
스프링 프레임워크 특징
(1) POJO 기반 프레임워크
(2) DI (Dependency Injection) 지원
(3) AOP (Aspect Oriented Programming) 지원
(4) 뛰어난 확장성
(5) Model2 방식의 MVC Framewordk 지원
(6) WAS에 종속되지 않는 개발 환경

(1) POJO 기반 프레임워크
- 자바 객체의 라이프사이클을 스프링 컨테이너가 직접 관리혹
- 스프링 컨테이너로부터 필요한 객체를 얻어 옴

(2) DI (Dependency Injection) 지원
- 의존성 주입
- 의존 관계에 있는 객체를 생성 조립해 주는 기능
- 각 계층이나 서비스들 사이 또는 객체들 사이의 의존성이 존재할 경우 스프링 프레임워크가 서로 연결시켜 줌
- 클래 간 약한 결합 가능
- A 클래스 B클래스의 객체를 사용할 때
-- 지금까지 B b = new B(); // 개발자가 필요할 때 언제든지 new 사용해서 의존관계가 있는 객체 생성/사용
-- 스프링에서는 new 연산자로 마음대로 객체 생성 못함
-- 스프링 컨테이너가 만들어서 넣어 주겠다는 의미

(3) AOP (Aspect Oriented Programming) 지원
- 관점 지향 프로그래밍
- 공통 기능을 분리해서 사용해서 사용
-- 트랜잭션 로깅, 보안 등 여러 모듈에서 공통적으로 지원하는 기능을 분리해서 사용 
- 반복적인 코드를 줄이고 개발자가 비즈니스 로직에만 집중할 수 있도록 지원

(4) 뛰어난 확장성
- 스프링 프레임워크의 소스는 모두 라이브러리로 분리되어 있어서
- 필요한 라이브러리만 가져다 사용하면 됨
- web.xml에 추가

(5) Model2 방식의 MVC Framewordk 지원
- Model / View / Controller
- JSP MVC 때보다 코드가 간결

핵심 기능
- DI (Dependency Injection) 주입 
-- 객체 간의 의존성을 개발자가 설정하는 것이 아니라
-- 스프링 컨테이너가 주입시켜 주는 기능
-- 장점 : 객체를 쉽게 확장하고 재사용할 수 있음
- IoC (Inversion of Control : 제어의 역전)
-- 객체에 대한 제어권 문제
-- 기존에는 개발자에게 제어원이 있었음 : new 연산자 사용해서 마음대로 객체 생성
-- 스프링 프레임워크에서는 객체의 제어권이 스프링에게 있고
-- 인스턴스의 라이프사이클(생성에서 소멸까지)을 개발자가 아닌 스프링 프레임워크에서 담당
-- 제어권이 역전되었다는 표현

----------------------------------------------------------------------------------------

개발환경 구성
- JDK
- Spring Toos 
-- STS (Spring Tool Suit) 사용 : 이클립스에 스프링 플러그인이 포함된 버전 -- 우리는 이 방식 사용
-- Eclipse에서 Spring Tools 플러그인 설치
- Tomcat
- Oracle Database 11g Release 2 : Express Edition

설치 및 환경 설정
- STS4 설치 : Spring Boot만 설치
- Spring Tools 3 Add-On 3.9.16 추가 설치
- Eclipse Java EE Developer Tools 설치

먼저 Workspace 생성
- springWorkspace

STS4 다운로드 받아서 압축해제하고 exe 파일 실행 사용

STS4 다운로드
- spring-tool-suite-4-4.10.0.RELEASE-e4.19.0-win32.win32.x86_64.self-extracting.jar
압축 해제 : 주이!
- 압축 해제 시 경로가 길다는 오류 발생
- C 또는 D로 이동하고
- 파일명을 sts.jar 로 줄임
- sts.jar 압축 해제
- contents.zip 압축 해제
- sts-4.10.0.RELEASE 폴더 이동
- SpringToolSuite4.exe 실행 (작업 표시줄에 고정)

메뉴 Help / Eclipas MarketPlace에서 다음 검색해서 설치
(1) STS로 검색 : Spring Tools 3 Add-On 3.9.16  - install
(2) Eclipse Java EE Developer Tools  검색 : 
-- Eclipse Enterprise Java and Web Developer Tools 3.21 - install
(3) Perspective 변경 : Open Perspective / Spring 선택해서 Open

환경 설정 : Window / Preference에서 다음 설정
(1) General / Workspace : 아래 오른쪽에 OTHER : UTF-8 로 변경
(2) HTML / CSS / JSP : UTF-8로 변경 (오른쪽 위에)
(3) Server 설정
   - Runtime Environment
   - Apache Tomcat v9.0
   - Create a new local server
   - 톰캣 폴더 선택
(4) Java Compiler 버전 변경 --> 1.8로 변경
     - Java / Compiler 오른쪽 위에 15 -> 1.8로 변경

----------------------------------------------------------------------------------------
스프링 프로젝트 유형
스프링 : 자바 기반 웹 프레임워크

스프링 웹 프로젝트
(1) Spring Legacy Project
-- 스프링 템플릿 프로젝트를 이용하는 프로젝트
(2) Spring Starter Project
-- Spring Boot을 이용하는 프로젝트

(1) Spring Legacy Project
- 스프링 템플릿 프로젝트를 이용하는 프로젝트
- 모델2 방식 (MVC)의 프로젝트 생성 시 사용
- Spring MVC Project
- 서버 및 여러 설정 필요
- 실제 개발 업무에서 많이 사용하는 프로젝트

(2) Spring Starter Project
- Spring Boot을 이용하는 프로젝트
- 최대한 간단하게 실행하고, 배포가 가능한 수준의 웹 어플리케이션을 제작하기 위한 목적
- 개발에 필요한 모든 환경을 설정을 갖추면서 최소한의 개발을 해야 하는 경우 사용
- 개발자가 복잡한 설정 없이 모든 개발 환경이 준비되기 때문에 초보 개발자도 쉽게 웹 프로젝트 생성 가능

Simple Spring Maven (Maven Project)
 - Spring 라이브러리의 기본 세트를 포함하는 Maven을 사용해서
- 간단한 Spring 프로젝트 생성

Maven (메이븐)
- Java 용 프로젝트 관리 도구
- XML 기반의 정적인 빌드 제공

Gradle(그레이들)
- 그루비(Groovy) 스크립트 기반의 동적인 빌드 기능 제공
- 안드로이드 앱 만들 때 필요한 공식 빌드 시스템
- 메이븐보다 빌드 작업이 간단
- 별도의 스크립트를 통해서 사용할 애플리케이션 버전, 라이브러리 등 설정 가능


------------------------------------------------------------------------------------------------

의존성 (Dependency)
- 객체 간 의존성
- 한 클래스에서 다른 클래스의 객체를 통해 그 클래스의 메소드를 실행할 때 '의존'한다고 표현
- xxxDAO dao;  xxxDTO dto;
- new 연산자를 통해 다른 클래스의 객체 생성해서 사용
--  BookDTO dto = new BookDTO();

A 클래스에서 B 클래스이 객체를 생성해서 사용하는 경우

(1) 지금까지 해왔던 개념
- A클래스에서 직접 생성
- 일체형으로 묶여 있음
- 강한 의존 관계
class A {
  privat B b;

  public A(){
     b = new B(); // B클래스의 객체 b 생성
   }
}

(2) 앞으로 사용할 개념 (DI)
- 외부에서 만든 객체를 받아서 사용
- (조립된 부품을 받아서 사용한다는 개념)

class A {
  privat B b;

  public void setB(B b){  // setter 메소드를 통해서 외부에서 넣어 줌 (injection)
     this.b = b;
  }
}

DI (Dependency Injection) 주입 
-- 객체 간의 의존성을 개발자가 설정하는 것이 아니라
-- 스프링 컨테이너가 주입시켜 주는 기능
-- 장점 : 객체를 쉽게 확장하고 재사용할 수 있음
- IoC (Inversion of Control : 제어의 역전)
- 외부에서 생성된 bean(객체)fmf IoC 컨테이너가 넣어 주는 방식 (주입 : injection)
- 일반적으로 부품(빈)을 조립(의존성 주입)해서 사용한다는 개념

DI(의존성 주입) 방법을 사용하는 이유
- 의존하는 객체의 클래스가 변경되거나 다른 클래스의 객체를 사용하게 될 경우
-- 의존 관계에 있는 다른 모든 클래스들의 소스 코드도 변경해햐 하는데
- 의존성 주입 방법을 사용하면, 클래스 결합 상태를 변경하거나 객체를 주입하는 부분만 수정하면 되므로
- 수정할 코드의 양을 줄일 수 있다는 장점이 있음
예) A1 클래스를 사용하다가 A2 클래스로 변경할 경우
- 설정 파일세서 클래스 이름만 변경해 주면 됨
<bean id="a" class="com.package.A1">
			       A2


스프링에서 의존성 주입 방법
(1) XML을 이용한 방법
- XML 설정 파일에 <bean> 설정
-- 생성자 기반 DI
-- Setter 기반 DI
(2) Annotation을 이용한 방법
- 자바 코드에서 '@어노테이션'으로 설정

------------------------------------------------------------------------------
프로젝트 생성
- 도메인 이름 형식 : com.company.app

Group id (도메인 이름) : com.di_project.ex
Artifact id (프로젝트 이름) : di_01

실습 예제
(1) DI를 사용하지 않은 예제
- Controller 클래스와 Service 클래스 사이에 의존성 존재
- Controller 클래스에서 new 연산자 사용해서 Service 클래스 객체 생성해서 사용
com.di.no_spring_no_di
- nameService
- nameController
- nameMain

(2) 생성자 기반 DI
- 의존성이 있는 객체를 new를 사용해서 직접 생성하지 않고
- 생성자를 통해 외부에서 전달 (주입 : inject)
- 아직 스프링의 DI는 아님
- com.di.no_spring_di_constructor

(3) Setter 기반 DI
- Setter 메소드를 사용해서 의존성 주입 수행
com.di.no_spring_di_setter

-----------------------------------------------------------------------------
Spring DI
스프링으 의존성 주입 : 스프링의 핵심 기능
- 스프링 프레임워크는 컨테이너 역할을 하기 때문에
- 스프링 컨테이너(IoC 컨테이너)라고도 함
- 스프링은 필요한 빈을 생성해서 컨테이너에 넣어 관리
- 필요한 곳에 주입해 줌
- 빈을 생성하기 위한 설정과 의존 객체를 주입시키는 설정 필요

2가지 Spirn DI
(1) XML을 이용한 DI : 별도의 설정파일(xml)을 사용해서 빈 생성, 객체 주입 설정
    - 생성자 기반 DI
    - Setter 기반 DI
(2) Annotation을 이용한 DI

(1) XML을 이용한 DI
- XML 파일에
-- 빈(Bean: 부품)을 정의(생성)하고
      - <bean id="빈이름" class="패키지명.클래스명">
-- 의존성 설정 (부품 조립 : DI )
     - <ref bean="의존하는 빈">
- XML을 이용해서 의존성을 주입하기 위해서는
-- 생성자 기반일 때는 생성자가 반드시 있어야 하고
-- Setter 기반일 때는 Setter 메소드가 반드시 있어야 함


스프링은 Pre-loading 방식 사용
- ApplicationContex를 이용해서 컨테이너를 구동하면 
- 컨테이너가 구동되는 시점에 스프링 설정 파일에 등록된 빈을 생성하고 컨테이너에 로드

-----------------------------------------------------------------------------------------------------
스프링 DI 실습
(1) XML을 이용한 DI : 생성자 기반
 - 클래스에 생성자가 있어야 하고
 - 스프링 설정 파일(xml)에서 빈을 정의할 때
   <constructor-arg ref="의존하는 빈">
com.di_spring_di_xml_constructor

설정 파일 생성 : xml 
src/main/resources 폴더에 Srping Bean Configuration File 선택하고
application-context.xml

NameMain 클래스에서 하는 역할
- 컨테이너 객체를 생성하고  ;
AbstractApplicationContext context = 
	new GenericXmlApplicationContext("application-context.xml");
라이브러기 없어서 오류 -> pom.xml 파일에 라이브러리 추가
- 컨테이너에 컴포넌트(빈) 가져옴


pom.xml 파일에서 Dependencies Add 안될 때
Window / Preference
- 왼쪽에서 Maven : 오른쪽에서 [Download repository index updates on startup 체크
- Apply and Close 창 닫고
Window / Show View / Other
- Maven : Maven Repositories 서택하고 open
오른쪽 아래에 창이 열리면
Global Repositories / central에 우클릭하고 Rebuild Index
- 시간이 오래 걸림
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>5.2.13.RELEASE</version>
  	</dependency>
  	<dependency>

-----------------------------------------------------------------------------------------------
연습문제1
패키지 : com.di.spring_di_xml_constructor_ex1
클래스 생성
- Speaker 클래스
   -- volumeUp() : 볼륨을 키웁니다
   -- volumeDown() : 볼륨을 낮춥니다
- TV 클래스
   -- Speaker speaker;
   -- volumeUp() / volumeDown()
   -- TV 클래스에서 Speaker 클래스의 volumeUp()/volumeDwon()를 호출해서 볼륨 조졸
- TVMain 클래서
- XML 기반으로 생성자를 통해 DI 구현
   -- appplication-context2.xml


-----------------------------------------------------------------------------------------------
(2) XML을 이용한 DI : Setter 기반
 - 클래스에 반드시 Setter 메소드가 있어야 한다
 - 생성자 사용 안함 (기본 생성자 외에 다른 생성자 없음)
 - 스프링 설정 파일 (xml)에서 <property> 태그 이용해서 의존 객체 주입
 - <property name="nameService" ref="nameService">
    -- name : setter 메소드 이름 (setNameService())
    -- ref : 참조 객체 이름 (참조하는 빈 이름)

패키지 : com.di.spring_di_xml_setter

----------------------------------------------------------------------------------------
연습문제2
패키지 : com.di.spring_di_xml_setter_ex1
클래스 생성
- Speaker 클래스
   -- volumeUp() : 볼륨을 키웁니다
   -- volumeDown() : 볼륨을 낮춥니다
- TV 클래스
   -- Speaker speaker;
   -- volumeUp() / volumeDown()
   -- TV 클래스에서 Speaker 클래스의 volumeUp()/volumeDwon()를 호출해서 볼륨 조졸
- TVMain 클래서
- XML 기반으로 Setter 메소드를 통해 DI 구현
   -- appplication-context4.xml

----------------------------------------------------------------------------------------

설정 파일에서 빈 생성하면 값 초기화 (값 설정)
- 생성자 기반
- Setter 기반
com.di.spring_xml_value_constructor
com.di.spring_xml_value_setter

연습문제3
com.di.spring_xml_value_setter
application-context7.xml
Book 클래스
- 설정 파일에서 빈 생성하면서 값 초기화 
- Setter 기반


설정 파일에서 빈 생성하면 값 초기화 (값 설정) - 의존성 주입
com.di.spring_di_xml_value_contructor

설정 파일에서 빈 생성하면 값 초기화 (값 설정) - 의존성 주입 
- Setter 기반
com.di.spring_di_xml_value_setter
- application-context8.xml
- BMI / Member / MemberMain

------------------------------------------------------------------------------------------
스프링에서 Singleton
- 스프링 컨테이너는 빈을 생성할 때 싱글톤 패턴을 적용하지 않아도
- 항상 클래스당 1개의 인스턴스만 생성 (디폴트)

singleton 속성 변경 가능
- <bean> 태그의 scope 속성을 이용해서
- 빈이 싱글톤으로 생성되게 할지
- 아니면 요청할 때마다 생성되게 할지 설정 가능
- scope 속성 값 : singleton(디폴트), prototype, thread, request, session, application

==========================================================
Annotation을 이용한 DI
- xml 설정 파일에서 <bean> 태그를 이용해서 설저하였던 빈 설정을
- Annotation(메타데이터)를 이용해서 자바 코드에서 설정
예 : xml 설정 파일에서 빈을 설정하지 않ㄴ고
- 스프링이 자바 소스 코드를 읽어서
- 클래스에 @Component 어노테이션이 붙은 클래슬 객체화 (bean 설정)
- A1 클래스의 객체를 A2클래스의 객체로 변경하려면
-- A1 클래스에서 @Component을 제거하고 
-- A2 클래스에 @Component을 붙이면 됨
--@Autowired 어노테이션을 사용하여 bean 자동 삽입

xml 설정 파일에 context 네임스페이스 추가
- 빈 설정을 위한 어노테이션을 사용하기 위해서는
- 설정 파일에 context 네임스페이스가 추가되어 있어야 함
- <context:component-scan> 태그 이용해서 빈으로 등록될 클래스 패키지 지정
- 의미 : 자바 소스 코드에서 @Component로 등록된 클래스를 찾아서(scan) 클래스를 객체화(빈 설정)

Annotation 종류
- 빈 생성과 관련 Annotation
    @Component
      - @Controller
      - @Service
      - @Repository
    @Configuration
      - @Bean
- DI 관련 Annotation
--@Autowired / @Inject
--@Qualifer
--@Resource

DI 관련 Annotation
- xml 설정 파일에 있는 <bean>에 대해 DI 하거나
- 자바 코드에서 생성된 bean에 대해 DI할 수 있음
- @Autowired : 타입을 기준으로 의존성 주입
-- 스프링 빈에 의존하는 다른 빈을 자동으로 주입할 때 사용
-- 스프링에서 지원
-@Inject : @Autowired와 동일 (자바에서 지원)
-@Qualifer : 특정 빈의 이름 지정
-- 동일한 interface를 구현한 클래스가 여러 개 있는 경우
-- 사용하고자 하는 특정 빈의 이름을 지정할 때 사용
-@Resource : @Autowired와 @Qualifer를 같이 사용하는 것과 동일 (자바에서 지원)


프로젝트 새로 생성
New / Maven 프로젝트 생성
- Create a simple project 체크
- Group Id (도메인 이름) : com.di_project.ex
- Aritifact Id (프로젝트 이름) : di_02
- pom.xml <dependencies> 추가 : di_01프로젝트에서 복사
 <dependencies>
  	<dependency>
  		<groupId>org.springframework</groupId>
  		<artifactId>spring-context</artifactId>
  		<version>5.2.13.RELEASE</version>
  	</dependency>
  </dependencies>


패키지 생성 : com.spring_di_annotation
필요한 클래스
- INameService 인터페이스 
- NameService 클래스
- NameController 클래스
- NameMain 클래스

설정 파일 : application-context.xml
- Annotation을 사용하기 위해서는 context 네임스페이스 추가
-- application-context.xml 생성한 후 아래쪽에 Namespaces 탭 선택
-- context 체크
- 빈 생성

(1) @Autowired : 스프링 빈에 의존하는 다른 빈을 자동으로 주입할 때 사용
(2) @Qualifer : 동일한 interface를 구현한 클래스가 여러 개 있는 경우
	       -- 사용하고자 하는 특정 빈의 이름을 지정할 때 사용
(3) @Resource : @Autowired와 @Qualifer를 같이 사용하는 것과 동일

@Autowired의 위치
- 클래스 선언부 : 기본 생성자를 호출하면서 injection
- Setter 메소드 위에 : Setter 메소드 호출하면서 injection
 
-------------------------------------------------------------
빈 생성과 관련 Annotation
    @Component
      - @Controller
      - @Service
      - @Repository
    @Configuration
      - @Bean

빈 생성 어노테이션
- 빈 생성(설정)을 위해 클래스 위에 추가되는 어노테이션
- 클래스 이름 위에 붙이면 해당 클래스 파일에 대한 bean 자동 생성 
-(xml 파일에서 bean 생성하지 않음)
- 빈의 이름은 클래스 이름에서 첫 문자 소문자
예: NameService 클래스의 빈 이름은 nameService

어노테이션을 이용하기 위해 xml 설정 파일에서 필요한 작업
- xml 설정 파일에 context 네임스페이스 추가 필요
<context:component-scan base-package="패키지명" />
-@Component 어노테이션이 적용된 클래스를 빈으로 등록

@Component 어노테이션
- 클래스를 빈으로 등록 (부품 등록)
- 빈 id 지정 가능
- @Component("빈이름") == <bean id="빈 이름">에 해당

패키지 : com.spring_di_annotation_component
사용 클래스
- INameService 인터페이스: 변경 없이 그대로 사용
- NameService 클래스 : 빈 생성
-- @Component 어노테이션 추가
- NameController 클래스 : 빈 생성
-- @Component 어노테이션 추가
   -- 생성자 삭제
   -- NameService 객체 사용
-NameMain 클래스 : xml 파일명만 변경
-- NameController 클래스 사용

@Component 어노테이션의 의미론적 어노테이션
@Component : 일반적인 컴포넌트
특화된 @Component 어노테이션
- 클래스의 역할에 따라 의미론적으로 구분
-- @Controller 컴포넌트 : 컨트롤러 클래스에 사용
-- @Service 컴포넌트 : 서비스 클래스에 사용
-- @Repository 컴포넌트 : DAO 클래스 또는 Repository 클래스에 사용

패키지 : com.spring_di_annotation_component2


--------------------------------------------------------------------------
설정 담당 자바 클래스에서 사용하는 어노테이션
@Configuration
- 빈 설정 클래스임을 나타내는 어노테이션

@Bean 
- 빈을 생성해서 반환해주는 어노테이션
- 빈을 생성하는 메소드 앞에 기술
- @Bean이 붙은 메소드는 반드시 Bean 반환

@Bean 어노테이션을 사용하는 경우
- 일반적으로 @Controller, @Service, @Repository 어노테이션을 붙이지 않는 클래스의 빈 생성에 사용

패키지명 : com.spring_di_annotation.configuration_bean
사용 클래스
- BMI
- Member
- MemberMain
- ApplicationConfig.java


=========================================================
Spring MVC 구조

- Spring MVC Project 생성
- 설정
- 구조 확인
- 데이터 전송
- 폼을 통한 데이터 전송

New / Spring MVC Project
프로젝트 이름 : spring_mvc_01
패키지 이름 : com.spring_mvc.project

(1) pom.xml 버전 변경
기본 환경 확인
- Spring Framework 3.1.1
- Java version 1.6
- Maven compiler
-- source 1.6
-- target 1.6

변경할 버전
-Spring Framework 4.3.4
- Java version 1.8
- Maven compiler
-- source 1.8
-- target 1.8

(2) 프로젝트 설정 변경 (프로젝트 이름 우클릭)
- Java Compiler : 1.8
- Java Build Path : JRE 수정
- Project Facets : Java 버전 변경 (1.8)

(3) Maven / Update Project


----------------------------------------------------------
프로젝트 이름 : spring_mvc_01
패키지 이름 : com.spring_mvc.project
http://localhost:8080/project/


프로젝트 처음 생성 시
- 기본 컨트롤러 포함되어 있음 : HomeController
-- src / main
-- C:\springWorkspace\spring_mvc_01\src\main\java\com\spring_mvc\project
- 기본 view 페이지 : home.jsp
-- 아래 : src / main/ webapp/WEB_INF/views/ 여기에 home.jsp 들어 있음

HomeController
- @RequestMapping(value = "/", method = RequestMethod.GET)
- 요청 url 맵핑 : "/" : /project를 의미 : 요청을 받고
--처리 작업
- 결과를 View 페이지에 전송
-- return "home";  // view 페이지 이름 : home.jsp

/WEB-INF/views/ + view 페이지 이름 + .jsp

설정 파일 확인
1. web.xml  : /  :요청 url 맵핑 : "/" : /project를 의미 : 요청을 받고
(1) 요청 url 
- <servlet-mapping>
	<servlet-name>appServlet</servlet-name>
	<url-pattern>/</url-pattern>
</servlet-mapping>

(2) DispatcherServlet : 컨트롤러를 찾아서 작업 처리
(3) 스프링 컨테이너 설정 파일 위치 지정
/WEB-INF/spring/appServlet/servlet-context.xml

2.  servlet-context.xml 파일 확인
- 응답 페이지 설정되어 있음
- ViewResolver가  jsp 위치 찾고, 해당 jsp 파일 찾도록 설정
-(1) "/WEB-INF/views/ : view 페이지의 위치
-(2) name="suffix" value=".jsp" : 뷰페이지 이름 확장자 (.jsp 파일)
-- view 페이지 위치 +   여기에 뷰 페이지 이름     + .jsp : 뷰 페이지로 설정

컨트롤러에서 뷰 페이지 이름 반환 : home

스프링의 디렉터리 구조
- src/main/java : 자바코드 위치(Controller, Service, model)
- src/main/resources : 자바 코드에서 참조하는 리소스 파일들 (DB 설정파일)

- src/main/webapp : 웹 서비스 루트 디렉터리 (외부에서 접근 가능)
- src/main/webapp/resources : js, css, image 등 리소스 파일

- src/main/webapp/WEB-INF/spring : 스프링 환경 설정 파일 
	-- servlet-context.xml : 서블릿과 관련된 리소스에 대한 설정
	-- root-contxt.xml : 서블릿과 관련 없는 모든 리소스에 대한 설정

- src/main/webapp/WEB-INF/views : html, jsp 페이지 (컨트롤러를 경유해서 접근 가능) (외부에서는 직접 접근 불가(보안상)

server.xml에서 context path 확인 : 패캐지 이름에서 맨 마지막 . 다음에 오는 이름이 컨텍스트 패스가 됨
<Context docBase="spring_mvc_01" path="/project"

패키지 이름 : com.spring_mvc.project
http://localhost:8080/mvc/
http://localhost:8080/mvc/project

http://localhost:8080/mvc/WEB-INF/classes/com/spring_mvc_01/project/HomeController.java
http://localhost:8080/project/WEB-INF/classes/com/spring_mvc/project/HomeController.java


------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------
스프링 컨트롤러
- 스프링 컨트롤러는 빈으로 등록되어야 하며
- 비즈니스 로직이 실행되기 전에 비즈니스 객체를 의존성 주입(DI) 해야 함
- @Controller 어노테이션 사용
- @RequestMapping 어노테이션을 사용해서 url 맵핑 : 사용자의 요청 받음


- 컨트롤러 클래스 새로 작성
- 클래스 생성하고  @Controller 어노테이션 붙임
- @RequestMapping 어노테이션을 사용해서 요청 경로 지정
- 요청 처리 메소드 구현
- 뷰 페이지 이름 반환 : return "jsp 페이지 이름"


---------------------------------------------------------------
연습문제
- 새 컨트롤러 생성 : SecondController
- url 맵핑 : /secondView
- jsp 페이지 : views/second 폴더 만들어서 그 안에 secondView.jsp 생성
- SecondController에게 요청해서 secondView.jsp 출력

-------------------------------------------------------------------------------
컨트롤러에서 View 페이지로 데이터 전달 방법
(1) Model 인터페이스 객체 사용
(2) ModelAndView 클래스 객체 사용

(1) Model 인터페이스
- Model에 Attributes 추가하는데 사용
- ("key", value) 형태로 값을 임시 저장
- Controller에서 Model에 데이터 저장하고
- View 이름 return 하면
- View 페이지로 Model 전달되고
- View 페이지에서 key를 사용해서 Model에 저장된 Data 사용 : ${key }

나이 : 30
주소 : 서울시 강남구
전화 : 010-1234-1234


(2) ModelAndView 클래스 객체 사용
- 데이터와 뷰 둘 다 설정
-- 데이터 설정 : addObject(key, value)
-- 뷰 이름 설정 : setViewName("jsp파일 이름")
- 반환값으로 ModelAndView 객체 반환
- ModelAndView mv = new ModelAndView();
- mv.addObject("name", "홍길동")
- mv.setViewName("showInfo");   // showInfo.jsp
- return mv;


연습문제
- 컨트롤러 : BookController
- Views 폴더 안에 book 폴더 생성 : bookInfoView.jsp

- 데이터 
-- 제목 : 스프링 프레임워크
-- 가격 : 20000
-- 저자 : 홍길동

- 메소드 
- showBookInfo1() : Model 사용
- showBookInfo2() : ModelAndView 사용

- 요청 url 
- bookInfoView1
- bookInfoView2

--------------------------------------------------------------------
@RequestMapping 다중 맵핑
- 한 개의 메소드를 사용해서 여러 요청 경로로 접근 처리 가능
- @RequestMapping(value={"요청경로1", "요청경로2"})


--------------------------------------------------------------------
Form 데이터 처리
- 폼에 입력된 값을 컨트롤러로 전송
- 스프링에서 HTTP 요청 파라미터 가져오는 방법 3가지
(1) getParameter() 메소드 사용
(2) @RequestParam 어노테이션 사용
(3) Command 객체 이용
- Student 클래스 생성하고 요청을 수행하는 메소드에서 Student 객체 사용 (커맨드 객체)
- Command 객체는 자동으로 View Model에 등록
- View 페이지에서 ${객체.필드명}

index.jsp 만들고 
실행하면 바로 index.jsp 실행되게 설정

요청 : / 이면
view 이름 : index


@ModelAttribute 어노테이션
- Comman 객체 이름 변경 가능
- Student student 인 경우 : ${stuedent.no}

- @ModelAttribute("studentInfo") Student student
- ${studentInfo.no}


------------------------------------------------------------------------------
연습문제

새 프로젝트 : spring_mvc_02
패키지 : com.spring_mvc.product
(http://localhost:8080/product/)

상품 정보를 등록하는 프로그램 작성
- 상품 정보 등록 폼에서 입력한 데이터를 컨트롤러에게 전송하고
- 컨틀로러에서 받아온 데이터를 View 페이지로 출력
- 3가지 방법 사용 (getParameter() / @RequestParam /Command 객체)

- 컨트롤러 : ProductController
- 폼 : productForm.jsp
- 결과 출력 : productResult1.jsp, productResut2.jsp

- jsp 위치 : product 폴더 만들고 그 안에 위치
- insertProduct1() / insertProduct2() / insertProduct3()


------------------------------------------------------------------------------------------

MyBatis(마이바티스)
- ORM(Object Relation Mapping: 객체 관계 맵핑) 프레임워크
- 자바에서 JDBC를 이용해서 데이터베이스 연동할 때
- Java 언어와 sql 언어가 한 파일에 존재하면서 재사용성이 좋지 않음
- MyBatis는 JDBC의 이런 단점을 개선해서 sql 명령어를 별도의 xml 파일로 분리해서
- sql 명령어와 자바 객체를 맵핑해준 기능을 제공
- sql 명령어 재사용 가능

MyBatis 특징 : SQL 명령어를 자바 코드에서 분리해서 XML 파일에서 관리

JDBC를 사용할 경우
- Controller  -> IService/Service  -> IDAO(선택) / DAO (sql 문장)  -> DB

MyBatis 사용할 경우
- Controller  -> IService/Service  -> IDAO(필수) / mapper.xml(sql 문장)  (DAO 대신 mapper.xml 사용)

프로젝트명 : spring_project_ex
패키지명 : com.spring.projectEx

스프링 MyBatis 사용하기 위한 설정 
(1) 프로젝트 생성
(2) pom.xml에서 의존성 설정
    - 프로젝트 
	- Java Compiler : 1.8
	- Java Build Path : JRE 수정
	- Project Facets : Java 버전 변경 (1.8)
    - 데이터베이스 (Spring JDBC 의존성 / Connection Pool 의존성 / Oracle JDBC Driver 의존성)
    - MyBatis 
(3) web.xml 인코딩 필터 추가
(4) 프로퍼티 파일 작성 : jdbc.properties
(5) 스프링 설정 파일 생성 : application-config.xml
     - DataSource / Mapper 지정
(6) web.xml : 스프링 설정 파일 지정
(7) 클래스 구성 (CRUD)
    Controller
    IService / Service
    VO
   IDAO / mapper.xml
  뷰 페이지 (jsp) : select / insert / update / delete / index

		

데이터베이스 작업
- 관리자 : 사용자 생성 : SRPING
- 새접속 : SPRING실습
- 사용자 : SPRING
- 비밀번호 : 1234
- 테이블 생성 : product


------------------------------------------------------------------------------------------------------------
1. 프로젝트 생성

New / Spring MVC Project
프로젝트 이름 : spring_mvc_mybatis
패키지 이름 : com.spring_mvc.mybatis

(1) pom.xml 버전 변경
기본 환경 확인
- Spring Framework 3.1.1
- Java version 1.6
- Maven compiler
-- source 1.6
-- target 1.6

변경할 버전
-Spring Framework 4.3.4
- Java version 1.8
- Maven compiler
-- source 1.8
-- target 1.8

(2) 프로젝트 설정 변경 (프로젝트 이름 우클릭)
- Java Compiler : 1.8
- Java Build Path : JRE 수정
- Project Facets : Java 버전 변경 (1.8) / 톰캣 체크

(3) Maven / Update Project (데이터베이스와 마이바티스 설정 끝난 후에)

------------------------------------------------------------------------------------------------------------------
 데이터베이스 (Spring JDBC 의존성 / Connection Pool 의존성 / Oracle JDBC Driver 의존성)
ojdbc-6.jar

C:\oraclexe\app\oracle\product\11.2.0\server\jdbc\lib 에 들어 있는 ojdbc6.jar 파일을 아래 폴더에 복사하고
C:\Users\student\.m2\repository\com\oracle\ojdbc\6 폴더에 저장 (폴더 없으면 새로 생성)
파일명을 ojdbc-6.jar 파일로 변경

---------------------------------------------------------------------------------------------------------------------
MyBatis 의존성 설정

<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis</artifactId>
			<version>3.5.6</version>
		</dependency>
		<dependency>
			<groupId>org.mybatis</groupId>
			<artifactId>mybatis-spring</artifactId>
			<version>2.0.6</version>
		</dependency>
-------------------------------------------------------------------------------------------------------------------------

(3) web.xml 인코딩 필터 추가  (한글 깨짐 방지)

------------------------------------------------------------------------------------------------------------------------

(4) 프로퍼티 파일 작성 : jdbc.properties
위치 : src/main/resources에 database 폴더 만들고 jdbc.properties 파일 생성

데이터베이스 연결 정보 설정
- 프로퍼티 파일에 작성 해 놓음
- 이 파일 안 만들고 설정 파일 안에 직접 넣어도 됨
- 프로퍼티 파일을 만들어서 사용하는 이유 : 보안 때문
-- DB 연결 정보는 내용이 변경될 수 있으므로 외부 .properties 파일로 작성해서 별도로 관리
-- git 저장소에 DB 접속 정보가 노출되지 않도록 하기 위함

------------------------------------------------------------------------------------------------------------------
(5) 스프링 설정 파일 생성 : application-config.xml
     - DataSource / Mapper 지정

위치 : src/main/resources에 spring 폴더 만들고 application-config.xml 파일 생성

----------------------------------------------------------------------------------------------
(6) web.xml : 스프링 설정 파일 지정


	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>classpath:/spring/application-config.xml</param-value>
	</context-param>


================================================================

(7) 클래스 구성 (CRUD)
    Controller
    IService / Service
    VO
   IDAO / mapper.xml
  뷰 페이지 (jsp) : select / insert / update / delete / index

------------------------------------------------------------------------------------------------------------

패키지 생성
controller : ProductController 클래스    @Controller / @Autowired
dao : IProductDAO (인터페이스)
       ProductMapper.xml
model : ProductVO 클래스
service : IProductService 인터페이스     @Service
           ProductService 클래스
          

--------------------------------------------------------------------------------
ProductMapper.xml
https://mybatis.org/mybatis-3/getting-started.html 에서 복사

<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">


----------------------------------------------------------------------------------
사용자 요청 (전체 상품 조회)   ->  Controller    ->  Service      ->    IDAO/Mapper.xml
		 	<-	      <-		<-					


상품 등록  -> 상품 등록 폼 이동 (입력) ->  저장

-----------------------------------------------------------------------------------------------------
연습문제
- 새프로젝트 생성 
- 도서 관리 프로그램 작성
- 테이블 : 새로 작성 또는 기존 테이블 사용

프로젝트 : spring_mvc_mybatis_book
패키지명 : com.spring_mybatis.book
도서 관리 프로그램 작성
- 전체 도서 정보 조회
- 도서 상세 정보 조회
- 도서 정보 등록
- 도서 정보 수정
- 도서 정보 삭제


=================================================================
Ajax (Asynchronous JavaScript and XML)
- 클라이언트에서 비동기 방식으로  자바스크립트를 이용해서
- 화면 전환 없이 서버 측에 데이터를 요청할 때 사용
- HTML, XML, JOSN, 텍스 등의 다양한 데이터 처리 가능
- 웹 서버 환경에서 실행

형식 : jQuery 형식 (jQuery 파일이 있어야 함)
$.ajax({
  url : "전송되는 페이지 ( ~로 전송)",
  type: "데이터 전송 방식 (get/post)",
  data: "전송할 데이터",
  dataType: "요청하는 데이터 타입(html, xml, json),
  success: function(data, textStatus){  //결과를 받을 매개변수 사용
     전송 및 요청 성공 시 실행 부분
  }, 
  error: function(data, , textStatus){
    오류 발생 시 실행 부분
  },
  complete:function(data, , textStatus){
    완료 시 실행 부분
  }
});

$.ajax() 메소드
- 사용자가 지정한 URL 경로에 있는 파일의 데이터를 전송하고
- 입력한 URL 경로의 파잉로부터 요청한 데이터를 불러오는데 사용
- 불러올 수 있는 외부 데이터는 텍스트, HTML, XML, JSON 유형 등

serialize() : 폼에 입력한 값을 쿼리 스트링 방식의 데이터로 변환여 액션 페이지에 전송
- 예 : 'id=abcd&pawd=1234$name=kim,...'

과제1 : html/JavaScript : 입력한 값 alert()추력
과제2: Ajax() 사용해서 서버로 보내고
 (가정: DB에서 다 처리했다고 하고 가정하고) 
보낸 값을 다시 클라이언트로 보내서 alert() 출력

--------------------------------------------
서블릿 : AjaxTest1 (/ajaxTest1)

클라이언트로 부터 데이터 받아서
Console에 출력하고
클라이언트에게 "안녕하세요. 서버입니다." 결과 데이터 전송

-----------------------------------------------------------------------------------------------------
CDATA : Unpared Character Data
- 파싱되지 않는 문자 데이터 
- sql 쿼리 작성할 떄 <, >, &, || 등을 사용해야 하는 경우 
- XML에서 태그로 인식해서 오류가 발생
- XML에게 XML 파싱 대상이 아니고 단순 문자열로 처리하라는 의미

<![CDATA[
select * from product where prdPrice > 10000;
]]>

-------------------------------------------------------------------------------------------------------
스프링 REST API

REST 
- 브라우저에서 페이지 요청 시
- PC에서는 페이지 전체를 다시 전송해서 표시해도 문제 없지만
- 스마트폰 등의 모바일 기기에서는 기존 화면은 그대로 유지하면서 필요한 내용만 추가해서 화면엣 표시
- 모바일 기기가 유선 기기보다 네트워크 전송량이 떨어지므로 
- 현재 화면은 그대로 유지하면서 필요한 데이터만 전송 받아서 빠르게 표시하기 위해서
- 대표적인 경우 : Ajax 이용
- 따라서 데이터만 전송하는 기능 표준화 필요성에 대두되면 REST 방식이 대안으로 사용됨

REST (Represnetation State Transfer)
- URI가 고유한 리소스를 처리하는 공통 방식
- 세션 정보나 쿠키 정보를 별도 저장하고 관리하지 않고 API 서버는 들어오는 요청만 단순 처리
- RESP API 설계 기준
 - URI 정보의 자원 표현
 - 자원에 대한 행위 HTTP(GET, POST, PUT, DELETE)로 표현

- REST API 중심 규칙
- URI는 정보의 자원을 표현해야 한다
- 자원 표현 
GET /members/1
DELET /members/2
POST /members/3
- 슬래시 구분자는 계층 관계를 나타내는 대 사용
- 마지막에는 슬래시 (/) 포함하지 않음
- URI 소문자로 사용
- 파일 확장자는 포함하지 않음

REST 방식으로 제공되는 API를 REST API (또는 RESTful API)라고 함
- 트위터와 같은 Open API 에서 많이 사용
- 정송 방식을 나타내는 메소드 속성의 값에 따라 리소스에 대한 추가 작업 요청 

스프링에서의 REST 방식의 데이터 처리
- 스프링 3버전 : @ResponseBody 어노테이션 지원
- 스프링 4버전 : @RestController 어노테이션

@RestController 이용해 REST 기능 구현
- 컨트롤러에서 브라우저로 기본형 데이터, VO 객체의 속성 값, Map에 저장된 데이터 전송
 - 서버 --> 클라이언트 데이터 전송

@Controller VS @RestController
- @Controller : 결과를 jsp(view)로 표시
- @RestController : 별도의 view를 제공하지 않은 채 데이터 전달


=================================================================
@RestController 사용해서 클라이언트로 문자열 전송

프로젝트 생성 : Spring MVC Project
프로젝트명 : spring_mvc_rest
패키지명 : com.spring_mvc.rest

1.8
4.3.4
1.8
1.8

(1) Java Compiler : 1.8
(2) Build Path : JRE edit 
(3) Project Facets : 1.8, 3.0, Runtime Server

--------------------------------------------------------------------------------------------------
- servlet-context.xml 설정 파일에서 
- 컨트롤러 없이 index 페이지 설정하는 방법
<mvc:view-controller path="/" view-name="index" />

-------------------------------------------------------------------------------------------------

@RestController를 이용해서 VO 객체 전달
- VO 객체의 속성 정보를 JSON 형식으로 전달
- pom.xml JSON 의존성 추가
<!-- JSON  --> 
<dependency>
	<groupId>com.fasterxml.jackson.core</groupId>
	<artifactId>jackson-databind</artifactId>
	<version>2.5.4</version>
</dependency>

@RestController를 이용해서 컬렉션 객체 전달
- List를 JSON으로 만들어서 전송

@RestController를 이용해서 Map 전달
- Map에 저장된 데이터 전송

@PathVariable을 사용하면 브라우저에서 요청 URL로 전달된 매개변수 값을 가져올 수 있음

----------------------------------------------------------------------
@RequestBody와 @ResponseBody 사용하기
- 실제로 REST는 Ajax 기능과 연동해서 자주 사용
- 브라우저에서 JSON 데이터를 컨틀로러 전송될 때 컨트롤러에서 JSON 객체로 변환하는 기능 구현

@RequestBody : 브라우저에서 전달되는 JSON 데이터를 객체로 자동 변환 (클라이언트 -> 서버)
@ResponseBody : 브라우저에게 JSP가 아닌 텍스트나 JSON으로 결과 전송 (서버 -> 클라이언트)
   - @Controller 클래스에서 사용

리소스 파일 (image, css, js)  경로 설정
- servlet-context.xml
<mvc:resources location="/resources/" mapping="/**" />
<mvc:resources location="/resources/js/" mapping="js/**" />

- src/main/webapp/resources 폴더

------------------------------------------------------------------------------------------------------
views에 JSONTest.jsp


-------------------------------------------------------------------------------------------------------
FrontEnd 프로젝트 : html, js, css, image을 스프링 프로젝트로 옮김


js, css, image 파일 : 리소스 파일 
- 위치 : src/main/webapp/resources 폴더에 위치
- 설정 파일 (servlet-context.xml)에서 리소스 경로 지정

index.jsp에 index.html 내용 복사

index.jsp / top.jsp / bottom.jsp 로 분리

지금 만든 index.jsp 이름 변경  -> index01.jsp
새로 보내주는 index.jsp로 사용(경로를 jstl 사용)


views 폴더 안에 jsp 폴더 생성 
jsp - top.jsp / bottom.jsp

index.jsp에서 잘라 오기
- top.jsp : 첫 줄~</nav> 잘라서 붙여 넣기
	- </body></html>
	- <div id="wrap"> 삭제

- bottom.jsp : <footer>~</footer> 잘라서 <body>안에 붙여 넣기

-------------------------------------------------------------------------------------------
로그인 기능 구현
- 회원 클래스 파일 필요
-- MemberVO
-- IMemberService
-- MemberService
-- IMemberDAO
-- MemberController
-- MemberMapper.xml

- 로그인 폼이동
- 로그인 체크 
-- id와 비밀번호 일치하면 세션 변수로 저장
-- 세션 변수 값에 따라 top 메뉴 항목이 다르게 출력
-- 로그인 전 : 로그인 회원가입
-- 로그인 후 : ~님 환영합니다 로그아웃 게시판 장바구니 MyPage

======================================================

아이디 중복 체크
- pom.xml에 JSON 의존성 추가
- 회원 가입 폼으로 이동
- id 중복체크 : ajax() 사용

--------------------------------------------------------------------------------------------
스프링 부트 (Spring Boot)
- 스프링 프레임워클 사용하는 프로젝트를 아주 간편하게 설정할 수 있는 스프링 프레임워크 서브프로젝트
- 톰캣 설치 등 여러 가지 복잡한 설정 필요 없음
- xml 기반 설 정 과정 없이 프로젝트를 시작할 수 있음
- 메이븐의 pom.xml 파일에 의존성 라이브러리의 버전을 일일이 지정하지 않아도 됨 (스프링 부트가 권장 버전 관리)
- 단독 실행되는 스프링 애플리케이션 구현 가능
- 톰캣 등 환경 구축에 필요한 서버 외적인 툴이 내장되어 있어서 별도 설치 필요 없음
- 스프링 부트 전용 STS 
- JSP 뷰가 기본이 아니기 때문에 JSP 뷰를 사용할 경우
-- application.properties 파일에 설정 추가
-- pom.xml에 의존성 추가
-- src/main/webapp 폴더에 WEB-INF 폴더와 views 폴더 추가
- application.properties 파일이 web.xml 대신하는 설정 파일
- main() 메소드 포함 : 스프링 부트 프로젝트는 main() 메소드를 시작점으로 실행
- main()이 반드시 있어야 함 
- 이유 : 스프링 부트의 웹 애플리케이션을 일반 자바 애플리케이션처럼 개발하려는 의도 때문

스프링 부트 프로젝트 생성
- New / Spring Starter Project 
- JDBC API
- Oracle Driver
- Spring Web

- 오라클 의존성을 선택했으므로 테이터베이스 연결 정보 필요
- applecation.properties 파일에 DB 연결정보 지정
- applecation.properties : web.xml 대신 설정파일로 사용

JSP 뷰가 기본이 아니기 때문에 JSP 뷰를 사용할 경우
-- application.properties 파일에 설정 추가
-- pom.xml에 의존성 추가
-- src/main/webapp 폴더에 WEB-INF 폴더와 views 폴더 추가


스프링 부트 프로젝트에 자동을 생성되는 클래스

(1)
@SpringBootApplication
public class Myboot01Application {

	public static void main(String[] args) {
		SpringApplication.run(Myboot01Application.class, args);
	}

}

- @SpringBootApplication : 스프링 부트 애플리케이션으로 설정하는 어노테이션
- main() 메소드 : 스프링 생성시 자동으로 생성
                    - 스프링 프로젝트는 반드시 main() 이 있어야 함


(2)
public class ServletInitializer extends SpringBootServletInitializer {

	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
		return application.sources(Myboot01Application.class);
	}

}

- SpringBootServletInitializer 역할 : 스프링 부트 애플리케이션을 web.xml없이 톰캣에서 실행하게 해주는 것
- 그래서 스프링부트에는 web.xml과  context.xml 설정 파일이 없음


=============================================================

세미 프로젝트 
- 스프링 레거시 프로젝트 : Spring MVC Project
- 쇼핑몰 기반으로 해서
- 필수 기능 구현
 -- 로그인 
 -- 회원가입
 -- (상품) 전체 목록 출력

최종 제출
- 프로젝트 계획서 : 수요일 오전 중 (11:50까지)
- 포트폴리오
- 프로젝트 압축 파일

발표 : 4월 23일 오후3시부터 시작

http://localhost:8080/test01

doGet()


----------------------------------
과제1
과제2 - 스프링 프로젝트 작성
- LoginController 
-- @RequestMapping("/hello")
-- @RequestParam("id") String id
-- String id = request.getParameter("id");
- Ajax() : post 
-- 데이터 : 클라이언트 --> 서버
--           클라이언트 <-- 서버



================================================
스프링 부트 프로젝트 생성
1. Tymeleaf 방식 - 과제에서 사용한 방식
- 의존성 설정
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
</dependency>
- html 파일 위치 : src/main/resources 아래 templetes 
- 리소스 파일 (image/css/js) : src/main/resources 아래 staic

2. JSP 뷰 사용
- JDBC API
- Oracle Driver
- Spring Web

- 오라클 의존성을 선택했으므로 테이터베이스 연결 정보 필요
- applecation.properties 파일에 DB 연결정보 지정
- applecation.properties : web.xml 대신 설정파일로 사용

JSP 뷰가 기본이 아니기 때문에 JSP 뷰를 사용할 경우
-- application.properties 파일에 설정 추가
-- pom.xml에 의존성 추가
-- src/main/webapp 폴더에 WEB-INF 폴더와 views 폴더 추가

자동 생성된 클래스 2개
(1) 
@SpringBootApplication  // 스프링 부트 애플리케이션으로 설정하는 어노테이션
public class BootJspApplication {
public static void main(String[] args) {
     SpringApplication.run(BootJspApplication.class, args);
}
} // 스프링 프로젝트는 반드시 main()이 있어야 함

(2) 역할 : 스프링 부트 애플리케이션을 web.xml 없이 톰캣에서 실행하게 해주는 것
public class ServletInitializer extends SpringBootServletInitializer {

@Override
protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
     return application.sources(BootJspApplication.class);
  }
}

==================================================
스프링 부트 프로젝트 생성 - MyBatis 사용
1. 스프링 부트 프로젝트 생성
(1) 프로젝트명 : bootMybatis
   Group : com.multi
   패키지명 : con.multi.bootMybatis
(2) Dependencies 선택
    SQL : JDBC API / Oracle Driver / MyBatis Framework
    Web : Spring Web
(3) 프로젝트 생성 후 확인
    - pom.xml 내용 확인
    - Oracle 확인 : ojdbc8로 자동 설정되어 있음
    - 자동 생성된 클래스

2. 스프링 설정 파일 : application.properties 파일 생성되어 있음
 application.properties에 추가
    - 포트번호
    - 데이터베이스 연결정보
    - JSP 뷰 설정
    - Mapper 위치 지정

JSP 뷰 페이지 설정
 - pom.xml에 의존성 추가
 - src/main/webapp 폴더에 WEB-INF / views 폴더 추가
 - index.jsp 생성
 - TestController에서 index.jsp 뷰 페이지로 설정하고 실행 확인

3. DB 연동 기능 구현
(1) 패키지 생성 : com.multi.product
    앞에서 했던 product 클래스 모두 복사
    ProductVO / IProductDAO / IProductService / ProductService / ProductController
    모든 view 페이지 복사 : product 폴더에 모든 jsp 파일 복사
(2) mapper 파일 위치할 폴더 생성 
--  src/main/resources 안에 mappers / product 폴더 생성하고 ProductMapper.xml 복사
(3) BootMybatisApplication 클래스에 추가
   - @ComponetScan(Product 컨트롤러 클래스 지정)
   - @MapperScan(IProductDAO 클래스)
(4) index.jsp에 링크 추가
(5) 실행 : 이전에 했던 DB 처리 작업 CRUD 다 실행

==========================================================
도서 관리 프로그램 작성
- 스프링 부트 프로젝트
- Oracle / MyBatis
- CRUD 기능 구현

==========================================================

형상관리 (버전관리)
CI/CD
DevOps

팀프로젝트를 진행하면서 
- 프로젝트 변경 사항이 있으면 팀원이 같이 공유하도록 최신 버전으로 항상 유지
- 개발자가 수동으로 버전 관리를 하게되면
- 거의 대부분 개발 마지막에 통합해서 테스트가 진행이 되는 경우 발생
- 개발 도중 품질관리가 전혀 이루어지지 않기 때문에 개발 후반에 많은 문제 발생

CI/CD : 버전 관리를 자동으로 지속적으로 수행한다는 의미

CI (Continuous Inegration) : 지속적 통합 (통합 자동화)
-- 코드에 대한 퉁합을 지속적으로 자동적으로 진행함으로써 품질을 향싱키고 유지

CD (Continuous Deploy 또는 Delivery) : 지속적 배포 (배포 자동화)
-- 소프트웨어가 항상 신뢰 가능한 수준에서 배포될 수 있도록 지속적으로 관리한다는 개념


CI 시스템 구축
- CI 서버가 Repository Server(Git 등)에 Commit된 소슬코드를 주기적으로 풀링해서 컴파일, 단위 테스트, 검사 등 과정 수행
- 신규 또는 업데이티된 소스코드의 결함 여부를 지속적으로 검증
- 검증 결과를 개발자에게 전달하고 결함 해결 

CI 구성 요소 
- CI 서버 : 빌드 프로세스 관리 서버 : Jenkins, Travis CI , 등
- Repository Server : 각 개발자의 프로젝트 버전 관리 : Get
- Build Tool : 소스코드 컴파일해서 실행 가능한 파일로 만드는 과정 : Maven, Gradle,...
- Test Tool : 작성된 코드로 자동으로 테스트 수행하는 도구 : Junit, Mocha 등

DevOps (데브옵스) (위키백과)
- 소스트웨어의 개발(Development)과 운영(Operations)의 합성어
- 사람, 프로세스, 기술 등 합집합
- 소프트웨어 개발자와 정보기술 전문가간의 소통, 협업 및 통합을 강조하는 개발환경 또는 문화를 데브옵스라고 함
- 소프트웨어 개발 조지과 운영조직 간의 상호 의존 및 협력관계

DevOps의 목적
- 소프트웨어 제품과 서비스를 빠른 시간에 개발 및 배로
- 운영 프로세의 예측 가능성, 효율성, 보안, 유지보수 가능성 등을 극대화
- 자동화 : (통합 자동화)/ (배포 자동화)

DevOps의 이점
- 제품 생산 프로세스 전 과정을 자동함으로써 제품을 더 빨리 빌드하여 고객 만족을 눂여 높은 성과 달성
- 출식 시간 단축
- 시장과 경쟁 지형에 따른 유연한 대응 가능
- 시스템 안정성 및 신뢰성 유지
- 평균 복구 시간 개선

-------------------------------------------------------------------------------------------
형상관리 시스템 (버전 관리 시스템)
- 조직의 핵심 자산인 소스코드의 개정과 백업 절차를 자동화하여 오류 수정 과정을 도와줄 수 있는 시스템
- 시스템 개발 중 어떤 의미 있는 변화들을 관리하는 체계
- 의미 있는 변화들 : 기능 개선, 오류 수정, 고객 요구사항 변경 등에 의한 소스코드 또는 산출물의 변경
- 수행 기능 : 여러 개발자들이 협업하며 코드를 작성하고 관리할 수 있는 기능
-- 소스코드이 백업 및 이전 버전으로 롤백 기능 등 수행

형상관리 시스템 (버전 관리 시스템)을 사용하는 이유
- 잘못되었을 때 복구를 돕기 위해서
- 프로젝트 진행 중 과거의 어떤 시점으로 돌아갈 수 있게 하기 위해서
- 여러 사람이 같은 프로젝트에 참여할 경우, 각자가 수정한 부분을 팀원 전체가 동기화하는 과정을 자동화하기 위해서
- 소스코드이 변경 사항을 추적하기 위해서
- 소스코드를 주가 수저했는지 추적하기 위해서
- 대규모 수정 작업을 더 안정하게 진행하기 위해서
- 가지치기(Branch)로 프로젝트에 영향을 최소화 하면서 새로운 부분을 개발하기 위해서
- 통합(Merge)로 검증이 끝난 후 새로이 개발된 부분을 본류에 합치기 위해서
- 많은 오픈 소스 프로젝트에서 어떤 형태로든 버전 관리를 사용하고 있기 때문에
- 코드의 특정 부분이 왜 그렇게 쓰여 졌는지 의미를 추적하기 위해서


형상 관리 도구
- 소스코드를 작성하거 관리하는 모든 개발자뿐만 아니라 디자이너, 기획자 등 
- 파일(프로젝트)에 대한 이력 관리가 필요한 경우에는 반드시 필요한 도구
- 상용 (유료)
- 오픈소스(무료) 
-- Git / Subversion(SVN), CVS, Mercurial 등

Git 
- 프로그램 등의 소스코드 관리를 위한 분산 버전 관리 시스템
- 여러 명의 개발자가 특정 프로젝트를 자신의 컴퓨터로 협업하여 개발하면서 버전을 관리할 수 있는 시스템

Git의 버전 관리 방식
- 중앙 서버 컴퓨터와 여러 개의 컴퓨터들이 연결되어 모두 같은 버전의 데이터베이스 유지
- 업데이트될 때마다 최신 버전이 자동으로 생성
- 파일들이 최신 버전으로 모든 컴퓨터에서 유지

Git의 특징
- 빠른 속도 (대형 프로젝트 사용하기 좋음)
- 단순한 구조
- 비선형적인 개발( 수천 개의 동시 다발적인 브랜치)
- 완벽한 분산 기능
- Github를 통해 웹 브라우저를 사용해서 누구나 저장소(Repository)를 쉽게 만들어 사용할 수 있음

Github
- 각 개발자들이 진행한 개발 변경 사항을 온라인에서 확인 가능한 서비스
- 오픈소스 배포 시 대부분 Git을 통해 배포 및 관리
- 저장 공간 무료 제공 : 단 모든 코드 공개해야 함 (강제 오픈 소스)
- 아니면 Private 저장 공간 제공 (유료 계정 사용)
- Repository push, pull 속도 빠르고 안정적
- 다른 형상관리 툴과 호환성 좋음

버전 관리 기법
- 로컬 버전 관리
- 중앙집중식 버전 관리
- 분산 버전 관리

로컬 버전 관리
- 이전의 디렉터리 파일 복사 방법
- 일반적으로 소스코드 또는 문서의 버전을 관리하기 위한 방ㅂ버
- 간단하고 자주 사용되는 방법이지만 작업 디렉터리를 잘못 지우거나 실수로 파일 잘못 변경한 또는 복사 할 수 있음
- 그래서 간단한 데이터베이슬 사용해서 파일의 변경 정보 관리

중앙집중식 버전 관리 시스템 
- Centralized Version Control Syteml : CVCS
- 파일을 관리하는 별도의 서버 존재
- 클라이언트가 중앙 서버에서 파일을 받아서 사용
- 장점 : 누가 무엇을 하고 있는지 관리자가 파악 가능
- 단점 : 중앙 서버 다운시 협업 불가능, 작업 백업 불가 문제 발생
	- 중앙 데이터베이스의 하드디스크에 문제가 생기면 프로젝트의 모든 히스토리를 잃게 됨

분산 버전 관리 시스템
- Distributed Version Control System : DVCS
- 모든 클라이언트에 서버의 저장소를 전부 복제
- 서버에 문제가 생기면 이 복제물로 작업 진행
- 리모트 저장 존재
- Git, Mecurial이 대표적


-------------------------------------------------
Github 사용법
- Github에 새 저장소 (Repository) 생성/삭제
- STS(또는 이클립스)에서 Github Local Repository 생성하고
- Github Repository 복제
- Local Repository에 프로젝트 추가
- 프로젝트 게시 : Github에 올리기
- Git Repository에서 프로젝트 가져오기 (Local Repository애 복제)
- Fork / Branch / 수정 작업 / Full Request / Merge

------------------------------------------------------------------------------
**** 리포지토리 생성 / 로컬 리포지토리로 복제 / 프로젝트 게시 ****


1. Github에 새 저장소 생성 (Repository 생성)
2. STS에서 로컬 리포지토리 생성 - 복제

3. 프로젝트 게시 순서 (로컬 리포지토리에서 Push)
(1) Share Project : 프로젝트 우클릭 (Team/Share Project)
(2) Git Repository 선택 : C:\Users\student\git\spring 선택하고 Finish
(3) 로컬 리포지터리에 추가된 프로젝트 확인
(3) Commit할 항목 선택 : Working Tree 선택된 상태에서
	- 오른쪽 아래 [Git Stagin] 탭에서 Add (초록색 아이콘) 클릭하면
	- 아래 Staged Changes로 이동
	- 오른쪽에 [ Commit Message 입력 : Initial Uplod
	- Commit 버튼 클릭
(4) Push : 로컬 리포지토리 맨 위의 spring[main]에 우클릭 : Push to origin
	- Login 정보 입력 / Close
(5) Github에서 확인 : Reppsitory 선택하고 프로젝트 내용 확인


3. 프로젝트 게시 순서 (프로젝트에서 Push)

(1) Share Project : 프로젝트 우클릭 (Team/Share Project)
(2) Git Repository 선택 : C:\Users\student\git\spring 선택하고 Finish
(3) Commit할 항목 선택 : 프로젝트 우클릭 : Team / Add to Index -> 아래 Staged Changes로 이동
		      프로젝트 우클릭 : Team / Commit
		       오른쪽에 [ Commit Message 입력 : Initial Uplod
		       - Commit 버튼 클릭

(4) Push : 프로젝트 우클릭 : Team / Push to Origin

------------------------------------------------------------------------------

로컬 리포지토리에서 프로젝트 가져오기
(1) 로컬 리포지토리에서 가져 오려는 프로젝트 우클릭하고 Import Projects
(2) import source 선택 
(3) import된 프로젝트 확인

------------------------------------------------------------------------------

리포지토리에서 프로젝트 삭제
- Github 사이트에서는 프로젝트만 삭제 안 됨 : 리포지토리 전체 삭제만 간증
- Command로는 삭제 가능
삭제 방법
- 로컬 리포지토리에서 프로젝트 삭제 후에
   - Commit : Commit Message 입력 ("~ 삭제")
   - Push to Origin


------------------------------------------------------------------------------

프로젝트 수정 작업
- jsp 파일 내용 수정 
- 프로젝트 수정하면 로컬 리포지토리 프로젝트에도 반영
- 프로젝트에서 
   -- Team / Add to Index
   -- Team / Commit : Commit Message 입력 ("index 페이지 수정") / Commit 버튼 클릭
   -- Team / Push to Origin
- Github에서 변경 사항 확인
   
연습문제
- 프로젝트 수정 작업 : HelloController.java 또는 다른 파일 내용 수정하고 Github에 반영 (서버에 변경 사항 반영)

------------------------------------------------------------------------------
Fork / Pull Requests / Merge

Fork : 다른 사람의 Github 저장소를 복사하여 내 저장소에 붙여넣기 하는 기능
Pull Requests : Fork로 가져온 코드 수정 후 게시하고 가져가라고 요청하는 것 (메일 전송)
Merge : 변경된 통합 (반영) (confirm : 확인했다고 메일 전송)
branch (가지 ) : Root 프로젝트로 부터 파생된 프로젝트
	- 코드 전체를 복사해서 독립적으로 개발하는 것 (자신 만의 버전)
	- 독립된 working directory


팀 프로젝트 저장소 생성
- 팀장 선출
- 팀원 : branch로 Fork 해서 작업 수행
	-- 수정된 내용 올리고 Pull Requests해서 팀장에게 가져가라고 메일 전송
- 팀장 : 메일 확인하고 Merge 작업 수행 / confrim 메일 전송

---------------------------------------------------------------------
(1) Fork : 다른 사람의 Github 저장소를 복사하여 내 저장소에 붙여넣기 하는 기능
(2) Pull Requests : Fork로 가져온 코드 수정 후 게시하고 가져가라고 요청하는 것 (메일 전송)
--- 팀장 메일 확인 했음
(3) Merge : 변경된 통합 (반영) (confirm : 확인했다고 메일 전송)
 


================================================================

파일 업로드
- MultipartFile 클래스 사용
- 스프링 부트에서는 의존성 설정 필요 없업
- application.properties 파일에서 파일 최대 크기만 설정

파일명이 중복되지 않고 파일 업로드
- UUID (Univerally Unique Identifier)
-- 소프트웨어 구축에 쓰이는 식별자 표준
-- 128비트의 숫자
-- 32개의 16진수로 표현, 총 36개 문자(32개문자 4개의 하이픈)로 8-4-4-4-12라는 5개의 그룹을 하이픈으로 구분
-- 자바 UUID 클래스의 randomUUID() 메소드를 사용해서 유일한 식별자 생성 - 파일 이름으로 사용
--- 새로 생성된 파일명 + 원본파일명

스프링 부트 프로젝트에서 파일 업로드/다운로드
- 파일 업로드/다운로드 폼 생성 
-- views / upload / fileUploadForm.jsp, fileDownloadForm.jsp
- 파일 업로드 결과 출력 페이지 생성 : fileUploadResult.jsp
- 패키지 생성 : com.multi.file
- 컨트롤러 생성 : FileUploadController / FileDownloadController
- 업로드된 파일 저장 위치 : 외부 폴더 생성 ("C:/upload" 폴더에 저장)


---------------------------------------------------------------------------------
파일 업로드
(1) 파일 업로드/다운로드 폼 생성 
- views / upload / fileUploadForm.jsp
(2) index에 링크 추가
(3) 패키지 생성 : com.multi.file
(4) FileUploadController 생성
    - BootMybatisApplication 클래스에 
    - @ComponentScan(basePackageClasses=FileUploadController.class) 등록
(5) 실행 : 업로드 파일 확인
(6) FileUploadController에 파일 업로드 처리 작업 추가
(7) fileUploadResult.jsp 파일 생성
(8) 실행 : 파일 업로드 결과 확인 ("c:/upload" 폴더 확인)

파일 다운로드
- 전체 파일 목록 출력
- 파일 목록에서 다운로드할 파일 선택하면
- 다운로드 폴더로 파일 다운로드 됨

(1) FileDownloadController 생성
(2) @ComponentScan(basePackageClasses=FileDownloadController.class) 등록
(3) fileDownloadForm.jsp 생성
(4) index.jsp에 경로 추가
(5) 실행해서 파일 다운로드 폼 확인
(6) FileDownloadController에 파일 다운로드 처리 작업 추가
(7) 실행 : 파일 다운로드 되는지 확인 (다운로드 폴더에 다운로드 됨)

---------------------------------------------------------------------------------
여러 개의 파일 업로드

- form : <input> 태그에서 multiple="multiple"로 설정
- upload 컨트롤러에서 ArrayList로 받음 :  ArrayList<MultipartFile> files
- for문 사용해서 파일 이름 변경, 파일 생성, 파일 서버로 전송

---------------------------------------------------------------------------------
파일이름 변경하지 않고 원본파일명으로 파일 업로드
- 저장할 폴더 : c:/upload/image
- upload 폼에 추가 
- upload 컨트롤러에 추가
- fileImageUploadResult.jsp 추가해서 c:/upload/image 폴더 확인하라고 출력




------------------------------------------------------------------
4/28 ~ 5/6 (6일)
   - 파이썬 기초 문법
   - 데이터 전처리
   - AI Makers Kit
5/7 ~ 5/18 (6일 + 멘토링)
   - Naver AI Platform
5/20 ~ 5/25 (4일)
   - Naver Cloud Service 배포
5/26 ~5/17 (14일 + 멘토링 + 강사)
   - 팀 프로젝트 진행 
   - 5/17 경진대회

------------------------------------------------------------------


스프링 부트 프로젝트에서 네이버 API 이용하여 도서 검색

- Spring Boot Project 생성 : Srping Web만 체크
-- bootAPI
- JSP의존성 설정
- 포트 번호 지정

- 네이버 개발자 센터에서 Open API 사용법 확인하고
- 도서 검색 프로그램 작성
- BookVO
- APIController
- BookService
- index.jsp
- bookListView.jsp